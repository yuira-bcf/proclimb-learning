<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第6章 継承とインタフェース</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700;900&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../../shared/common.css">
    <style>
      :root {
        --primary: #0097A7;
        --primary-dark: #00838F;
        --primary-light: #E0F7FA;
        --primary-lighter: #B2EBF2;
      }
      .nav-category-links { display: none; }
    </style>
</head>
<body>
    <nav class="global-nav"></nav>
    <script src="../../shared/js/nav-java.js"></script>

    <div class="container">
        <header class="chapter-header">
            <div class="chapter-badge"><span class="material-icons">menu_book</span> Chapter</div>
            <div class="chapter-number">6</div>
            <h1 class="chapter-title">継承とインタフェース</h1>
        </header>

        <nav class="toc">
            <h2 class="toc-title"><span class="material-icons">list_alt</span> この章の内容</h2>
            <ul class="toc-list">
                <li class="toc-item"><span class="toc-number">6-1</span><span>継承</span></li>
                <li class="toc-item"><span class="toc-number">6-2</span><span>メソッドのオーバーライド</span></li>
                <li class="toc-item"><span class="toc-number">6-3</span><span>継承関係におけるコンストラクタ</span></li>
                <li class="toc-item"><span class="toc-number">6-4</span><span>Objectクラスとレコードクラス</span></li>
                <li class="toc-item"><span class="toc-number">6-5</span><span>抽象クラス</span></li>
                <li class="toc-item"><span class="toc-number">6-6</span><span>インタフェース</span></li>
                <li class="toc-item"><span class="toc-number">6-7</span><span>シールクラス</span></li>
                <li class="toc-item"><span class="toc-number">6-8</span><span>参照型の型変換とポリモーフィズム</span></li>
                <li class="toc-item"><span class="toc-number">6-9</span><span>コレクションフレームワーク</span></li>
            </ul>
        </nav>

        <!-- セクション 6-1 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Section 6-1</span>
                <h2 class="section-title">継承</h2>
            </div>

            <div class="intro-text">
                <p>継承はオブジェクト指向の重要な概念で、既存のクラスを拡張して新しいクラスを作る仕組みです。コードの再利用性を高め、「is-a関係」（DogはAnimalである）を表現できます。Spring Frameworkでも、多くのクラスが継承を活用して設計されています。</p>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">1.1 クラスの継承関係</h3>
                <div class="content-block">
                    <p>継承により、既存クラスの機能を引き継いだ新しいクラスを作成できます。</p>
                    <div class="prompt-box">
                        <div class="prompt-box-header">
                            <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                            <span class="prompt-box-title">プロンプト</span>
                            <button class="prompt-copy-btn">コピー</button>
                        </div>
                        <div class="prompt-box-content">
                            <pre><code>## 機能
継承を使った動物クラスの階層の動作を確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter06
- ファイル名: InheritanceDemo.java

## 実装要件
- 親クラス(Animal)にprotectedフィールドnameを定義
- 親クラスにeat()メソッドを実装
- 子クラス(Dog)がAnimalをextendsで継承
- 子クラス独自のbark()メソッドを追加
- 子クラスから親クラスのフィールドにアクセス


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする
- 1ファイルで完結するよう、必要なクラスをすべて含める

## 使用するJava構文
- extends による継承
- protectedアクセス修飾子
- スーパークラスとサブクラスの関係</code></pre>
                        </div>
                    </div>
                    <div class="code-block">
                        <div class="code-header"><span class="code-title">chapter06/InheritanceDemo.java</span><span class="code-lang">Java</span></div>
                        <pre class="code-content"><code>// スーパークラス（親クラス）
class Animal {
    protected String name;

    public void eat() {
        System.out.println(name + "が食事中");
    }
}

// サブクラス（子クラス）
class Dog extends Animal {
    public void bark() {
        System.out.println(name + "がワンワン！");
    }
}

// 実行用メインクラス
public class InheritanceDemo {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.name = "ポチ";
        dog.eat();   // ポチが食事中
        dog.bark();  // ポチがワンワン！
    }
}</code></pre>
                    </div>
                    <div class="syntax-box">
                        <div class="syntax-box-header">
                            <span class="syntax-box-icon"><span class="material-icons">menu_book</span></span>
                            <span class="syntax-box-title">構文説明</span>
                        </div>
                        <div class="syntax-box-content">
                            <div class="syntax-item">
                                <h4>継承（extends）</h4>
                                <div class="syntax-pattern">class サブクラス extends スーパークラス { }</div>
                                <p>extendsキーワードで既存のクラス（スーパークラス）を継承し、新しいクラス（サブクラス）を定義します。サブクラスはスーパークラスのフィールドとメソッドを引き継ぎます。</p>
                            </div>
                            <div class="syntax-item">
                                <h4>protected修飾子</h4>
                                <div class="syntax-pattern">protected 型 変数名;</div>
                                <p>同じパッケージ内およびサブクラスからアクセス可能なアクセス修飾子です。継承関係でフィールドを共有したい場合に使用します。</p>
                            </div>
                        </div>
                    </div>
                    <div class="info-box">
                        <div class="info-box-header"><span class="info-box-icon"><span class="material-icons">lightbulb</span></span><span class="info-box-title">Javaの継承</span></div>
                        <p>Javaは単一継承のみ対応。1つのクラスは1つのクラスしか継承できません。複数の機能を持たせたい場合はインタフェースを使用します。</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- セクション 6-2 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Section 6-2</span>
                <h2 class="section-title">メソッドのオーバーライド</h2>
            </div>

            <div class="intro-text">
                <p>オーバーライドは、親クラスのメソッドをサブクラスで再定義する仕組みです。同じメソッド名で異なる振る舞いを実装できるため、ポリモーフィズム（多態性）の基盤となります。@Overrideアノテーションを付けることで、意図しないオーバーロードを防げます。</p>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">2.1 オーバーライドとsuper</h3>
                <div class="prompt-box">
                    <div class="prompt-box-header">
                        <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                        <span class="prompt-box-title">プロンプト</span>
                        <button class="prompt-copy-btn">コピー</button>
                    </div>
                    <div class="prompt-box-content">
                        <pre><code>## 機能
メソッドのオーバーライドとsuperキーワードの動作を確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter06
- ファイル名: OverrideDemo.java

## 実装要件
- 親クラス(Animal)にspeak()メソッドを定義
- 子クラス(Cat)でspeak()をオーバーライド
- @Overrideアノテーションを付ける
- super.speak()で親クラスのメソッドも呼び出す
- 子クラス独自の処理を追加


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする
- 1ファイルで完結するよう、必要なクラスをすべて含める

## 使用するJava構文
- @Overrideアノテーション
- メソッドのオーバーライド
- superキーワードで親メソッド呼び出し</code></pre>
                    </div>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-title">chapter06/OverrideDemo.java</span><span class="code-lang">Java</span></div>
                    <pre class="code-content"><code>class Animal {
    public void speak() {
        System.out.println("動物の声");
    }
}

class Cat extends Animal {
    @Override
    public void speak() {
        super.speak();  // 親クラスのメソッドを呼び出し
        System.out.println("ニャー");
    }
}

public class OverrideDemo {
    public static void main(String[] args) {
        Cat cat = new Cat();
        cat.speak();
        // 出力: 動物の声
        //       ニャー
    }
}</code></pre>
                </div>
                <div class="syntax-box">
                    <div class="syntax-box-header">
                        <span class="syntax-box-icon"><span class="material-icons">menu_book</span></span>
                        <span class="syntax-box-title">構文説明</span>
                    </div>
                    <div class="syntax-box-content">
                        <div class="syntax-item">
                            <h4>オーバーライド（@Override）</h4>
                            <div class="syntax-pattern">@Override
public 戻り値型 メソッド名(引数) { }</div>
                            <p>親クラスのメソッドをサブクラスで再定義します。@Overrideアノテーションを付けると、正しくオーバーライドされているかコンパイラがチェックします。</p>
                        </div>
                        <div class="syntax-item">
                            <h4>super（親メソッド呼び出し）</h4>
                            <div class="syntax-pattern">super.メソッド名(引数);</div>
                            <p>superキーワードで親クラスのメソッドを呼び出せます。オーバーライドしたメソッド内で、親の処理も実行したい場合に使用します。</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">2.2 @Overrideアノテーション</h3>
                <div class="content-block">
                    <p><code>@Override</code>を付けると、正しくオーバーライドされているかコンパイラがチェックします。付け忘れ防止に推奨。</p>
                </div>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">2.4 finalメソッドとfinalクラス</h3>
                <div class="prompt-box">
                    <div class="prompt-box-header">
                        <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                        <span class="prompt-box-title">プロンプト</span>
                        <button class="prompt-copy-btn">コピー</button>
                    </div>
                    <div class="prompt-box-content">
                        <pre><code>## 機能
finalキーワードの使い方を確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter06
- ファイル名: FinalDemo.java

## 実装要件
- finalメソッドを定義（サブクラスでオーバーライド不可）
- finalクラスを定義（他のクラスから継承不可）
- finalによる制限の効果を示す


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする
- 1ファイルで完結するよう、必要なクラスをすべて含める

## 使用するJava構文
- final修飾子（メソッド）
- final修飾子（クラス）
- 継承・オーバーライドの制限</code></pre>
                    </div>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-title">chapter06/FinalDemo.java</span><span class="code-lang">Java</span></div>
                    <pre class="code-content"><code>public class FinalDemo {
    public static void main(String[] args) {
        // finalメソッド：オーバーライド不可
        public final void cannotOverride() { }

        // finalクラス：継承不可
        public final class CannotExtend { }
    }
}</code></pre>
                </div>
                <div class="syntax-box">
                    <div class="syntax-box-header">
                        <span class="syntax-box-icon"><span class="material-icons">menu_book</span></span>
                        <span class="syntax-box-title">構文説明</span>
                    </div>
                    <div class="syntax-box-content">
                        <div class="syntax-item">
                            <h4>final修飾子</h4>
                            <div class="syntax-pattern">public final void メソッド名() { }

public final class クラス名 { }</div>
                            <p>finalを付けたメソッドはオーバーライドできません。finalを付けたクラスは継承できません。変更されたくない重要な処理を保護するために使用します。</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- セクション 6-3 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Section 6-3</span>
                <h2 class="section-title">継承関係におけるコンストラクタ</h2>
            </div>

            <div class="intro-text">
                <p>サブクラスのオブジェクトを生成する際、親クラスのコンストラクタも呼び出されます。super()を使って親クラスのコンストラクタを明示的に呼び出すことで、親クラスのフィールドを適切に初期化できます。この仕組みを理解することで、継承階層を正しく設計できます。</p>
            </div>

            <div class="prompt-box">
                <div class="prompt-box-header">
                    <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                    <span class="prompt-box-title">プロンプト</span>
                    <button class="prompt-copy-btn">コピー</button>
                </div>
                <div class="prompt-box-content">
                    <pre><code>## 機能
継承関係でのコンストラクタの呼び出しを確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter06
- ファイル名: SuperConstructorDemo.java

## 実装要件
- 親クラス(Animal)にコンストラクタを定義（nameを初期化）
- 子クラス(Dog)のコンストラクタでsuper()を使って親クラスのコンストラクタを呼び出す
- 子クラス独自のフィールド(breed)も初期化する
- super()は必ずコンストラクタの最初の行に記述


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする
- 1ファイルで完結するよう、必要なクラスをすべて含める

## 使用するJava構文
- super()によるコンストラクタ呼び出し
- 継承関係でのフィールド初期化
- コンストラクタチェーン</code></pre>
                </div>
            </div>
            <div class="code-block">
                <div class="code-header"><span class="code-title">chapter06/SuperConstructorDemo.java</span><span class="code-lang">Java</span></div>
                <pre class="code-content"><code>class Animal {
    protected String name;

    public Animal(String name) {
        this.name = name;
    }
}

class Dog extends Animal {
    private String breed;

    public Dog(String name, String breed) {
        super(name);  // 親クラスのコンストラクタを呼び出し（必須）
        this.breed = breed;
    }
}

public class SuperConstructorDemo {
    public static void main(String[] args) {
        Dog dog = new Dog("ポチ", "柴犬");
        System.out.println(dog.name);  // ポチ
    }
}</code></pre>
            </div>
            <div class="syntax-box">
                <div class="syntax-box-header">
                    <span class="syntax-box-icon"><span class="material-icons">menu_book</span></span>
                    <span class="syntax-box-title">構文説明</span>
                </div>
                <div class="syntax-box-content">
                    <div class="syntax-item">
                        <h4>super（親コンストラクタ呼び出し）</h4>
                        <div class="syntax-pattern">super(引数);</div>
                        <p>サブクラスのコンストラクタから親クラスのコンストラクタを呼び出します。必ずコンストラクタの最初の行に記述する必要があります。親クラスにデフォルトコンストラクタがない場合は必須です。</p>
                    </div>
                </div>
            </div>
            <div class="warning-box">
                <div class="warning-box-header"><span class="warning-box-icon"><span class="material-icons">warning</span></span><span class="warning-box-title">super()の位置</span></div>
                <p><code>super()</code>はコンストラクタの最初の行に記述する必要があります。</p>
            </div>
        </section>

        <!-- セクション 6-4 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Section 6-4</span>
                <h2 class="section-title">Objectクラスとレコードクラス</h2>
            </div>

            <div class="intro-text">
                <p>Objectクラスは全クラスの祖先であり、toString()やequals()などの基本メソッドを提供します。また、Java 16で導入されたレコードクラスは、データを保持するだけのクラスを簡潔に定義できる新機能です。DTOやエンティティの定義が格段に楽になります。</p>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">4.1 Objectクラス</h3>
                <div class="content-block">
                    <p>すべてのクラスは<code>java.lang.Object</code>を継承しています。主要メソッド：</p>
                    <ul class="bullet-list">
                        <li><code>toString()</code> - 文字列表現を返す</li>
                        <li><code>equals(Object)</code> - 等価性を比較</li>
                        <li><code>hashCode()</code> - ハッシュコードを返す</li>
                    </ul>
                </div>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">4.2 レコードクラス（Java 16以降）</h3>
                <div class="prompt-box">
                    <div class="prompt-box-header">
                        <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                        <span class="prompt-box-title">プロンプト</span>
                        <button class="prompt-copy-btn">コピー</button>
                    </div>
                    <div class="prompt-box-content">
                        <pre><code>## 機能
レコードクラスを使ったデータ保持の動作を確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter06
- ファイル名: RecordDemo.java

## 実装要件
- record キーワードでPersonレコードを定義
- nameとageをコンポーネントとして持つ
- レコードのインスタンス化と値の取得を示す
- toString()の自動生成を確認


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする
- 1ファイルで完結するよう、必要なクラスをすべて含める

## 使用するJava構文
- record キーワード（Java 16以降）
- イミュータブルなデータクラス
- 自動生成されるアクセサメソッド</code></pre>
                    </div>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-title">chapter06/RecordDemo.java</span><span class="code-lang">Java</span></div>
                    <pre class="code-content"><code>public class RecordDemo {
    public static void main(String[] args) {
        // データ保持用クラスを簡潔に定義
        public record Person(String name, int age) { }

        // 使用例
        Person p = new Person("Alice", 25);
        System.out.println(p.name());  // Alice
        System.out.println(p);  // Person[name=Alice, age=25]
    }
}</code></pre>
                </div>
                <p>レコードはイミュータブルで、equals/hashCode/toStringが自動生成されます。</p>
            </div>
        </section>

        <!-- セクション 6-5 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Section 6-5</span>
                <h2 class="section-title">抽象クラス</h2>
            </div>

            <div class="intro-text">
                <p>抽象クラスは「未完成の設計図」で、サブクラスに実装を強制します。共通の処理は親クラスで実装し、サブクラスごとに異なる処理は抽象メソッドとして宣言します。テンプレートメソッドパターンなど、設計パターンの基盤としても重要です。</p>
            </div>

            <div class="prompt-box">
                <div class="prompt-box-header">
                    <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                    <span class="prompt-box-title">プロンプト</span>
                    <button class="prompt-copy-btn">コピー</button>
                </div>
                <div class="prompt-box-content">
                    <pre><code>## 機能
抽象クラスを使った図形クラスの階層の動作を確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter06
- ファイル名: AbstractDemo.java

## 実装要件
- 抽象クラスShapeを定義（abstract修飾子）
- 抽象メソッドgetArea()を宣言（サブクラスで実装必須）
- 通常のメソッドprintColor()も含める
- 具象クラスCircleでShapeを継承しgetArea()を実装
- 面積計算のロジックをCircleクラスで実装


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする
- 1ファイルで完結するよう、必要なクラスをすべて含める

## 使用するJava構文
- abstract クラス宣言
- abstract メソッド宣言
- 抽象クラスの継承と抽象メソッドの実装</code></pre>
                </div>
            </div>
            <div class="code-block">
                <div class="code-header"><span class="code-title">chapter06/AbstractDemo.java</span><span class="code-lang">Java</span></div>
                <pre class="code-content"><code>abstract class Shape {
    protected String color;

    // 抽象メソッド（実装なし）
    public abstract double getArea();

    // 通常のメソッド
    public void printColor() {
        System.out.println("色: " + color);
    }
}

class Circle extends Shape {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }
}

public class AbstractDemo {
    public static void main(String[] args) {
        Circle circle = new Circle(5.0);
        System.out.println("面積: " + circle.getArea());
        circle.color = "赤";
        circle.printColor();  // 色: 赤
    }
}</code></pre>
            </div>
            <div class="syntax-box">
                <div class="syntax-box-header">
                    <span class="syntax-box-icon"><span class="material-icons">menu_book</span></span>
                    <span class="syntax-box-title">構文説明</span>
                </div>
                <div class="syntax-box-content">
                    <div class="syntax-item">
                        <h4>抽象クラス（abstract class）</h4>
                        <div class="syntax-pattern">public abstract class クラス名 { }</div>
                        <p>abstractを付けたクラスは直接インスタンス化できません。共通の処理を定義し、サブクラスで具体的な実装を行うための「設計図」として使用します。</p>
                    </div>
                    <div class="syntax-item">
                        <h4>抽象メソッド（abstract method）</h4>
                        <div class="syntax-pattern">public abstract 戻り値型 メソッド名();</div>
                        <p>abstractを付けたメソッドは本体を持たず、サブクラスで必ずオーバーライドして実装する必要があります。セミコロンで終わり、中括弧は書きません。</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- セクション 6-6 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Section 6-6</span>
                <h2 class="section-title">インタフェース</h2>
            </div>

            <div class="intro-text">
                <p>インタフェースは「契約」を定義します。実装クラスは、インタフェースで宣言されたメソッドを必ず実装しなければなりません。Javaは単一継承ですが、インタフェースは複数実装できるため、柔軟な設計が可能です。Spring BootのRepository、Serviceなどもインタフェースを活用しています。</p>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">6.1 インタフェースの作成と実装</h3>
                <div class="prompt-box">
                    <div class="prompt-box-header">
                        <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                        <span class="prompt-box-title">プロンプト</span>
                        <button class="prompt-copy-btn">コピー</button>
                    </div>
                    <div class="prompt-box-content">
                        <pre><code>## 機能
複数のインタフェースを実装したドキュメントクラスの動作を確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter06
- ファイル名: InterfaceDemo.java

## 実装要件
- Printableインタフェースにprint()メソッドを宣言
- Saveableインタフェースにsave()メソッドを宣言
- Documentクラスで両方のインタフェースを実装（implements）
- 各インタフェースのメソッドを@Overrideで実装


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする
- 1ファイルで完結するよう、必要なクラスをすべて含める

## 使用するJava構文
- interface キーワード
- implements による実装
- 複数インタフェースの実装（カンマ区切り）</code></pre>
                    </div>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-title">chapter06/InterfaceDemo.java</span><span class="code-lang">Java</span></div>
                    <pre class="code-content"><code>interface Printable {
    void print();  // 抽象メソッド（public abstract省略可）
}

interface Saveable {
    void save();
}

// 複数のインタフェースを実装可能
class Document implements Printable, Saveable {
    @Override
    public void print() {
        System.out.println("印刷中...");
    }

    @Override
    public void save() {
        System.out.println("保存中...");
    }
}

public class InterfaceDemo {
    public static void main(String[] args) {
        Document doc = new Document();
        doc.print();  // 印刷中...
        doc.save();   // 保存中...
    }
}</code></pre>
                </div>
                <div class="syntax-box">
                    <div class="syntax-box-header">
                        <span class="syntax-box-icon"><span class="material-icons">menu_book</span></span>
                        <span class="syntax-box-title">構文説明</span>
                    </div>
                    <div class="syntax-box-content">
                        <div class="syntax-item">
                            <h4>インターフェース（interface）</h4>
                            <div class="syntax-pattern">public interface インターフェース名 { }</div>
                            <p>クラスが実装すべきメソッドの「契約」を定義します。メソッドは暗黙的にpublic abstractです。フィールドはpublic static finalとなります。</p>
                        </div>
                        <div class="syntax-item">
                            <h4>implements</h4>
                            <div class="syntax-pattern">class クラス名 implements インターフェース1,
                         インターフェース2 { }</div>
                            <p>implementsキーワードでインターフェースを実装します。複数のインターフェースをカンマ区切りで指定でき、すべてのメソッドを実装する必要があります。</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">6.4 defaultメソッド（Java 8以降）</h3>
                <div class="prompt-box">
                    <div class="prompt-box-header">
                        <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                        <span class="prompt-box-title">プロンプト</span>
                        <button class="prompt-copy-btn">コピー</button>
                    </div>
                    <div class="prompt-box-content">
                        <pre><code>## 機能
defaultメソッドとstaticメソッドを持つインタフェースの動作を確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter06
- ファイル名: DefaultMethodDemo.java

## 実装要件
- Greetingインタフェースを定義
- defaultメソッドsayHello()を実装付きで定義
- staticメソッドprintVersion()を定義
- 実装クラスでオーバーライドしなくても使えることを示す


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする
- 1ファイルで完結するよう、必要なクラスをすべて含める

## 使用するJava構文
- default メソッド（Java 8以降）
- static メソッド（インタフェース内）
- インタフェースでのデフォルト実装</code></pre>
                    </div>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-title">chapter06/DefaultMethodDemo.java</span><span class="code-lang">Java</span></div>
                    <pre class="code-content"><code>public class DefaultMethodDemo {
    public static void main(String[] args) {
        public interface Greeting {
            default void sayHello() {
                System.out.println("Hello!");
            }

            static void printVersion() {
                System.out.println("Version 1.0");
            }
        }
    }
}</code></pre>
                </div>
                <div class="syntax-box">
                    <div class="syntax-box-header">
                        <span class="syntax-box-icon"><span class="material-icons">menu_book</span></span>
                        <span class="syntax-box-title">構文説明</span>
                    </div>
                    <div class="syntax-box-content">
                        <div class="syntax-item">
                            <h4>defaultメソッド（Java 8以降）</h4>
                            <div class="syntax-pattern">default 戻り値型 メソッド名() { 処理 }</div>
                            <p>インターフェースにデフォルトの実装を持つメソッドを定義できます。実装クラスはオーバーライドしなくても使用可能です。</p>
                        </div>
                        <div class="syntax-item">
                            <h4>staticメソッド（インターフェース内）</h4>
                            <div class="syntax-pattern">static 戻り値型 メソッド名() { 処理 }</div>
                            <p>インターフェース名.メソッド名()で呼び出せるstaticメソッドを定義できます。ユーティリティメソッドの定義に便利です。</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- セクション 6-8 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Section 6-8</span>
                <h2 class="section-title">参照型の型変換とポリモーフィズム</h2>
            </div>

            <div class="intro-text">
                <p>ポリモーフィズム（多態性）は、同じメソッド呼び出しでも実際のオブジェクトの型に応じて異なる処理が実行される仕組みです。これにより、型に依存しない柔軟なコードが書けます。フレームワークやライブラリの設計で広く活用されている重要な概念です。</p>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">8.1 アップキャストとダウンキャスト</h3>
                <div class="prompt-box">
                    <div class="prompt-box-header">
                        <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                        <span class="prompt-box-title">プロンプト</span>
                        <button class="prompt-copy-btn">コピー</button>
                    </div>
                    <div class="prompt-box-content">
                        <pre><code>## 機能
参照型の型変換（アップキャスト・ダウンキャスト）を確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter06
- ファイル名: CastDemo.java

## 実装要件
- アップキャスト：DogをAnimal型変数に代入（暗黙的）
- ダウンキャスト：Animal型からDog型に明示的キャスト
- instanceof演算子で型チェックしてから安全にキャスト
- パターンマッチング（Java 16以降）も示す


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする
- 1ファイルで完結するよう、必要なクラスをすべて含める

## 使用するJava構文
- アップキャスト（暗黙的型変換）
- ダウンキャスト（明示的型変換）
- instanceof演算子
- パターンマッチングinstanceof（Java 16以降）</code></pre>
                    </div>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-title">chapter06/CastDemo.java</span><span class="code-lang">Java</span></div>
                    <pre class="code-content"><code>class CastAnimal {
    protected String name;
    public CastAnimal(String name) { this.name = name; }
    public void eat() { System.out.println(name + "が食べる"); }
}

class CastDog extends CastAnimal {
    public CastDog(String name) { super(name); }
    public void bark() { System.out.println(name + "がワンワン！"); }
}

public class CastDemo {
    public static void main(String[] args) {
        CastAnimal animal = new CastDog("ポチ");  // アップキャスト（暗黙）
        animal.eat();  // OK

        // animal.bark();  // エラー：CastAnimal型にはbarkがない

        if (animal instanceof CastDog) {
            CastDog dog = (CastDog) animal;  // ダウンキャスト（明示）
            dog.bark();  // OK
        }

        // パターンマッチング（Java 16以降）
        if (animal instanceof CastDog dog) {
            dog.bark();  // キャスト不要
        }
    }
}</code></pre>
                </div>
                <div class="syntax-box">
                    <div class="syntax-box-header">
                        <span class="syntax-box-icon"><span class="material-icons">menu_book</span></span>
                        <span class="syntax-box-title">構文説明</span>
                    </div>
                    <div class="syntax-box-content">
                        <div class="syntax-item">
                            <h4>アップキャスト</h4>
                            <div class="syntax-pattern">親クラス型 変数 = new サブクラス();</div>
                            <p>サブクラスのインスタンスを親クラス型の変数に代入します。暗黙的に行われ、キャスト演算子は不要です。</p>
                        </div>
                        <div class="syntax-item">
                            <h4>ダウンキャスト</h4>
                            <div class="syntax-pattern">サブクラス型 変数 = (サブクラス型) 親クラス型変数;</div>
                            <p>親クラス型の変数をサブクラス型に変換します。明示的なキャストが必要で、instanceofで型チェックしてから行うのが安全です。</p>
                        </div>
                        <div class="syntax-item">
                            <h4>instanceof演算子</h4>
                            <div class="syntax-pattern">変数 instanceof クラス型</div>
                            <p>オブジェクトが指定した型かどうかを判定します。Java 16以降ではパターンマッチングで変数宣言も同時にできます。</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">8.6 ポリモーフィズム</h3>
                <div class="prompt-box">
                    <div class="prompt-box-header">
                        <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                        <span class="prompt-box-title">プロンプト</span>
                        <button class="prompt-copy-btn">コピー</button>
                    </div>
                    <div class="prompt-box-content">
                        <pre><code>## 機能
ポリモーフィズム（多態性）の動作を確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter06
- ファイル名: PolymorphismDemo.java

## 実装要件
- Animal型のListを作成
- DogとCatのインスタンスをリストに追加
- ループで各要素のspeak()を呼び出す
- 実際のオブジェクト型に応じた処理が実行されることを示す


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする
- 1ファイルで完結するよう、必要なクラスをすべて含める

## 使用するJava構文
- List&lt;親クラス型&gt;への異なるサブクラスの格納
- 拡張for文でのループ
- 動的ディスパッチ（実行時の型に基づくメソッド呼び出し）</code></pre>
                    </div>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-title">chapter06/PolymorphismDemo.java</span><span class="code-lang">Java</span></div>
                    <pre class="code-content"><code>import java.util.ArrayList;
import java.util.List;

class PolyAnimal {
    protected String name;
    public PolyAnimal(String name) { this.name = name; }
    public void speak() { System.out.println(name + "が鳴く"); }
}

class PolyDog extends PolyAnimal {
    public PolyDog(String name) { super(name); }
    public void speak() { System.out.println(name + "がワンワン！"); }
}

class PolyCat extends PolyAnimal {
    public PolyCat(String name) { super(name); }
    public void speak() { System.out.println(name + "がニャー！"); }
}

public class PolymorphismDemo {
    public static void main(String[] args) {
        List&lt;PolyAnimal&gt; animals = new ArrayList&lt;&gt;();
        animals.add(new PolyDog("ポチ"));
        animals.add(new PolyCat("タマ"));

        for (PolyAnimal animal : animals) {
            animal.speak();  // 実際の型に応じたメソッドが呼ばれる
        }
    }
}</code></pre>
                </div>
                <div class="syntax-box">
                    <div class="syntax-box-header">
                        <span class="syntax-box-icon"><span class="material-icons">menu_book</span></span>
                        <span class="syntax-box-title">構文説明</span>
                    </div>
                    <div class="syntax-box-content">
                        <div class="syntax-item">
                            <h4>ポリモーフィズム（多態性）</h4>
                            <div class="syntax-pattern">親クラス型 変数 = new サブクラス();
変数.メソッド(); // サブクラスのメソッドが実行される</div>
                            <p>親クラス型の変数でサブクラスのオブジェクトを扱い、実行時に実際のオブジェクト型に応じたメソッドが呼び出される仕組みです。これにより、型に依存しない柔軟なコードが書けます。</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- セクション 6-9 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Section 6-9</span>
                <h2 class="section-title">コレクションフレームワーク</h2>
            </div>

            <div class="intro-text">
                <p>コレクションは、複数のオブジェクトを格納・操作するためのデータ構造です。配列と違い、サイズを動的に変更でき、便利なメソッドが豊富に用意されています。List、Set、Mapは実務で最も頻繁に使うデータ構造であり、使いこなせることが必須スキルです。</p>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">9.2 ArrayList</h3>
                <div class="prompt-box">
                    <div class="prompt-box-header">
                        <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                        <span class="prompt-box-title">プロンプト</span>
                        <button class="prompt-copy-btn">コピー</button>
                    </div>
                    <div class="prompt-box-content">
                        <pre><code>## 機能
ArrayListの基本的な使い方を確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter06
- ファイル名: ListDemo.java

## 実装要件
- List&lt;String&gt;型でArrayListを生成
- add()で要素を追加
- get()でインデックス指定で要素を取得
- size()でリストのサイズを確認
- remove()で要素を削除


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする
- 1ファイルで完結するよう、必要なクラスをすべて含める

## 使用するJava構文
- ジェネリクス（List&lt;String&gt;）
- ダイヤモンド演算子（&lt;&gt;）
- ArrayListの主要メソッド</code></pre>
                    </div>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-title">chapter06/ListDemo.java</span><span class="code-lang">Java</span></div>
                    <pre class="code-content"><code>import java.util.ArrayList;
import java.util.List;

public class ListDemo {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("A");
        list.add("B");
        System.out.println("get(0): " + list.get(0));     // A
        System.out.println("size: " + list.size());        // 2
        list.remove(0);    // "A"を削除
        System.out.println("削除後: " + list);             // [B]
    }
}</code></pre>
                </div>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">9.4 HashMap</h3>
                <div class="prompt-box">
                    <div class="prompt-box-header">
                        <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                        <span class="prompt-box-title">プロンプト</span>
                        <button class="prompt-copy-btn">コピー</button>
                    </div>
                    <div class="prompt-box-content">
                        <pre><code>## 機能
HashMapの基本的な使い方を確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter06
- ファイル名: MapDemo.java

## 実装要件
- Map&lt;String, Integer&gt;型でHashMapを生成
- put()でキーと値のペアを追加
- get()でキーから値を取得
- containsKey()でキーの存在確認


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする
- 1ファイルで完結するよう、必要なクラスをすべて含める

## 使用するJava構文
- ジェネリクス（Map&lt;K, V&gt;）
- HashMapの主要メソッド（put, get, containsKey）
- キーと値のマッピング</code></pre>
                    </div>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-title">chapter06/MapDemo.java</span><span class="code-lang">Java</span></div>
                    <pre class="code-content"><code>import java.util.HashMap;
import java.util.Map;

public class MapDemo {
    public static void main(String[] args) {
        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
        map.put("Alice", 25);
        map.put("Bob", 30);
        System.out.println("get Alice: " + map.get("Alice"));           // 25
        System.out.println("containsKey Bob: " + map.containsKey("Bob")); // true
        System.out.println("map: " + map);                                // {Alice=25, Bob=30}
    }
}</code></pre>
                </div>
            </div>
        </section>

        <!-- 練習問題・解答 -->
        <section class="section">
            <div class="section-header"><span class="section-number">Exercise</span><h2 class="section-title">6章 練習問題</h2></div>
            <div class="exercise-list">
                <div class="exercise-item">
                    <div class="exercise-number">Q1</div>
                    <div class="exercise-content">
                        <p>インタフェースに定義できないものはどれですか？</p>
                        <ol type="A"><li>抽象メソッド</li><li>defaultメソッド</li><li>コンストラクタ</li><li>staticメソッド</li></ol>
                    </div>
                </div>
            </div>
        </section>

        <section class="section">
            <div class="section-header"><span class="section-number">Answer</span><h2 class="section-title">6章 解説・解答</h2></div>
            <div class="answer-list">
                <div class="answer-item">
                    <div class="answer-header">Q1の解答: C</div>
                    <div class="answer-content"><p>インタフェースはインスタンス化できないため、コンストラクタを持つことはできません。</p></div>
                </div>
            </div>
        </section>
    </div>

    <footer class="footer"><p>Java Silver 試験対策 教科書</p></footer>

    <div class="page-nav">
        <a href="5java-class.html" class="page-nav-btn prev"><span>&#8592;</span><div><div class="page-nav-label">前の章</div><div class="page-nav-title">第5章</div></div></a>
        <a href="7java-exception.html" class="page-nav-btn next"><div><div class="page-nav-label">次の章</div><div class="page-nav-title">第7章</div></div><span>&#8594;</span></a>
    </div>

    <script>
        function toggleMenu() {
            const toggle = document.querySelector('.nav-toggle');
            const menu = document.querySelector('.nav-menu');
            toggle.classList.toggle('active');
            menu.classList.toggle('active');
        }
        document.addEventListener('click', function(e) {
            const nav = document.querySelector('.global-nav');
            const toggle = document.querySelector('.nav-toggle');
            const menu = document.querySelector('.nav-menu');
            if (!nav.contains(e.target) && menu.classList.contains('active')) {
                toggle.classList.remove('active');
                menu.classList.remove('active');
            }
        });
    </script>
    <script src="../../shared/demo.js"></script>
</body>
</html>
