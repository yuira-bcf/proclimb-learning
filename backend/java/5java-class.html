<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第5章 クラスの宣言とインスタンス化</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700;900&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../../shared/common.css">
    <style>
      :root {
        --primary: #0097A7;
        --primary-dark: #00838F;
        --primary-light: #E0F7FA;
        --primary-lighter: #B2EBF2;
      }
      .nav-category-links { display: none; }
    </style>
</head>
<body>
    <nav class="global-nav"></nav>
    <script src="../../shared/js/nav-java.js"></script>

    <div class="container">
        <header class="chapter-header">
            <div class="chapter-badge"><span class="material-icons">menu_book</span> Chapter</div>
            <div class="chapter-number">5</div>
            <h1 class="chapter-title">クラスの宣言とインスタンス化</h1>
        </header>

        <nav class="toc">
            <h2 class="toc-title"><span class="material-icons">list_alt</span> この章の内容</h2>
            <ul class="toc-list">
                <li class="toc-item"><span class="toc-number">5-1</span><span>クラスとオブジェクト</span></li>
                <li class="toc-item"><span class="toc-number">5-2</span><span>クラスの作成</span></li>
                <li class="toc-item"><span class="toc-number">5-3</span><span>オブジェクトの生成とアクセス</span></li>
                <li class="toc-item"><span class="toc-number">5-4</span><span>アクセス修飾子の使用</span></li>
                <li class="toc-item"><span class="toc-number">5-5</span><span>メソッドのオーバーロード</span></li>
                <li class="toc-item"><span class="toc-number">5-6</span><span>オブジェクトの初期化</span></li>
                <li class="toc-item"><span class="toc-number">5-7</span><span>static変数とstaticメソッド</span></li>
                <li class="toc-item"><span class="toc-number">5-8</span><span>オブジェクトの扱い</span></li>
            </ul>
        </nav>

        <!-- セクション 5-1 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Section 5-1</span>
                <h2 class="section-title">クラスとオブジェクト</h2>
            </div>

            <div class="intro-text">
                <p>オブジェクト指向プログラミングの核心がここにあります。クラスとオブジェクトの概念を理解することで、現実世界のモノや概念をプログラムで表現できるようになります。Spring Bootでは、Controller、Service、Repositoryなど、すべてがクラスとして設計されています。</p>
            </div>

            <div class="content-block">
                <p><strong>クラス</strong>はオブジェクトの設計図（テンプレート）です。<strong>オブジェクト</strong>はクラスから生成された実体（インスタンス）です。</p>
                <div class="info-box">
                    <div class="info-box-header"><span class="info-box-icon"><span class="material-icons">lightbulb</span></span><span class="info-box-title">クラスとオブジェクトの関係</span></div>
                    <p>クラス = 設計図（例：「車」の定義）<br>オブジェクト = 実際の製品（例：「私の赤い車」「隣の青い車」）</p>
                </div>
            </div>
        </section>

        <!-- セクション 5-2 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Section 5-2</span>
                <h2 class="section-title">クラスの作成</h2>
            </div>

            <div class="intro-text">
                <p>クラスはメンバ変数（データ）とメソッド（振る舞い）で構成されます。良いクラス設計は、データと処理を適切にまとめ、外部からの不正なアクセスを防ぎます。この「何を公開し、何を隠すか」の設計が、保守性の高いコードにつながります。</p>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">2.1 クラス宣言</h3>
                <div class="prompt-box">
                    <div class="prompt-box-header">
                        <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                        <span class="prompt-box-title">プロンプト</span>
                        <button class="prompt-copy-btn">コピー</button>
                    </div>
                    <div class="prompt-box-content">
                        <pre><code>## 機能
人物情報を管理するPersonクラスの動作を確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter05
- ファイル名: Person.java

## 実装要件
- 名前(String)と年齢(int)をprivateフィールドとして持つ
- コンストラクタで名前と年齢を初期化する
- 自己紹介を出力するintroduce()メソッドを実装する


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする

## 使用するJava構文
- クラス宣言（public class）
- privateフィールド
- コンストラクタ（thisキーワード使用）
- publicメソッド</code></pre>
                    </div>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-title">chapter05/Person.java</span><span class="code-lang">Java</span></div>
                    <pre class="code-content"><code>public class Person {
    // メンバ変数（フィールド）
    private String name;
    private int age;

    // コンストラクタ
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // メソッド
    public void introduce() {
        System.out.println("私は" + name + "、" + age + "歳です");
    }

    public static void main(String[] args) {
        Person p = new Person("田中", 25);
        p.introduce();  // 私は田中、25歳です
    }
}</code></pre>
                </div>
                <div class="syntax-box">
                    <div class="syntax-box-header">
                        <span class="syntax-box-icon"><span class="material-icons">menu_book</span></span>
                        <span class="syntax-box-title">構文説明</span>
                    </div>
                    <div class="syntax-box-content">
                        <div class="syntax-item">
                            <h4>クラス宣言</h4>
                            <div class="syntax-pattern">public class クラス名 { }</div>
                            <p>クラスを定義する基本構文です。publicは他のパッケージからもアクセス可能にします。クラス名は大文字で始めるのが慣例です。</p>
                        </div>
                        <div class="syntax-item">
                            <h4>フィールド宣言</h4>
                            <div class="syntax-pattern">アクセス修飾子 型 変数名;</div>
                            <p>クラスのメンバ変数を宣言します。privateを使うとクラス外からの直接アクセスを防ぎ、カプセル化を実現できます。</p>
                        </div>
                        <div class="syntax-item">
                            <h4>コンストラクタ</h4>
                            <div class="syntax-pattern">public クラス名(引数リスト) { }</div>
                            <p>オブジェクト生成時に自動的に呼び出される特別なメソッドです。クラス名と同じ名前で、戻り値の型を書きません。</p>
                        </div>
                        <div class="syntax-item">
                            <h4>thisキーワード</h4>
                            <div class="syntax-pattern">this.フィールド名 = 引数名;</div>
                            <p>現在のインスタンス自身を参照します。引数とフィールドの名前が同じ場合に、フィールドを明示するために使用します。</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">2.2 メンバ変数</h3>
                <div class="content-block">
                    <p>クラス内で宣言された変数。オブジェクトの状態を保持します。</p>
                    <div class="prompt-box">
                        <div class="prompt-box-header">
                            <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                            <span class="prompt-box-title">プロンプト</span>
                            <button class="prompt-copy-btn">コピー</button>
                        </div>
                        <div class="prompt-box-content">
                            <pre><code>## 機能
商品情報を保持するProductクラスの動作を確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter05
- ファイル名: Product.java

## 実装要件
- 商品名(String)をデフォルトアクセスで定義
- 価格(int)をprivateで定義
- カテゴリ(String)をpublicで定義
- 各アクセス修飾子の違いを示す


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする

## 使用するJava構文
- アクセス修飾子（public, private, デフォルト）
- メンバ変数の宣言</code></pre>
                        </div>
                    </div>
                    <div class="code-block">
                        <div class="code-header"><span class="code-title">chapter05/Product.java</span><span class="code-lang">Java</span></div>
                        <pre class="code-content"><code>public class Product {
    String name;           // デフォルト（パッケージプライベート）
    private int price;     // プライベート
    public String category; // パブリック

    public static void main(String[] args) {
        Product p = new Product();
        p.name = "ノートPC";       // 同じパッケージ内からアクセス可能
        // p.price = 1000;         // コンパイルエラー（private）
        p.category = "電子機器";   // どこからでもアクセス可能
        System.out.println(p.name + " / " + p.category);
    }
}</code></pre>
                    </div>
                    <div class="syntax-box">
                        <div class="syntax-box-header">
                            <span class="syntax-box-icon"><span class="material-icons">menu_book</span></span>
                            <span class="syntax-box-title">構文説明</span>
                        </div>
                        <div class="syntax-box-content">
                            <div class="syntax-item">
                                <h4>フィールド宣言（アクセス修飾子別）</h4>
                                <div class="syntax-pattern">[アクセス修飾子] 型 変数名;</div>
                                <p><strong>private</strong>: 同じクラス内からのみアクセス可能。<strong>デフォルト（修飾子なし）</strong>: 同じパッケージ内からアクセス可能。<strong>public</strong>: どこからでもアクセス可能。</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">2.3 メンバメソッド</h3>
                <div class="prompt-box">
                    <div class="prompt-box-header">
                        <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                        <span class="prompt-box-title">プロンプト</span>
                        <button class="prompt-copy-btn">コピー</button>
                    </div>
                    <div class="prompt-box-content">
                        <pre><code>## 機能
計算機能を持つCalculatorクラスの動作を確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter05
- ファイル名: Calculator.java

## 実装要件
- 2つの整数を足し算して結果を返すadd()メソッドを実装
- 結果を出力するprintResult()メソッドを実装（戻り値なし）
- 戻り値ありとvoidメソッドの両方を含める


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする

## 使用するJava構文
- 戻り値を持つメソッド（return文）
- void型メソッド
- メソッドの引数</code></pre>
                    </div>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-title">chapter05/Calculator.java</span><span class="code-lang">Java</span></div>
                    <pre class="code-content"><code>public class Calculator {
    // 戻り値あり
    public int add(int a, int b) {
        return a + b;
    }

    // 戻り値なし（void）
    public void printResult(int result) {
        System.out.println("結果: " + result);
    }

    public static void main(String[] args) {
        Calculator calc = new Calculator();
        int sum = calc.add(10, 20);
        calc.printResult(sum);  // 結果: 30
    }
}</code></pre>
                </div>
                <div class="syntax-box">
                    <div class="syntax-box-header">
                        <span class="syntax-box-icon"><span class="material-icons">menu_book</span></span>
                        <span class="syntax-box-title">構文説明</span>
                    </div>
                    <div class="syntax-box-content">
                        <div class="syntax-item">
                            <h4>メソッド宣言</h4>
                            <div class="syntax-pattern">アクセス修飾子 戻り値型 メソッド名(引数リスト) { }</div>
                            <p>メソッドの基本構文です。戻り値がある場合はreturn文で値を返します。戻り値がない場合は戻り値型にvoidを指定します。</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">2.4 変数のスコープとthis</h3>
                <div class="prompt-box">
                    <div class="prompt-box-header">
                        <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                        <span class="prompt-box-title">プロンプト</span>
                        <button class="prompt-copy-btn">コピー</button>
                    </div>
                    <div class="prompt-box-content">
                        <pre><code>## 機能
thisキーワードの使い方を確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter05
- ファイル名: ThisDemo.java

## 実装要件
- privateフィールドnameを持つ
- setName()メソッドで引数とフィールドが同名の場合にthisを使って区別する
- メンバ変数と引数の名前を同じにして、thisの必要性を示す


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする

## 使用するJava構文
- thisキーワード
- setter メソッド
- 変数スコープの区別</code></pre>
                    </div>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-title">chapter05/ThisDemo.java</span><span class="code-lang">Java</span></div>
                    <pre class="code-content"><code>public class ThisDemo {
    private String name;

    public void setName(String name) {
        this.name = name;  // this.name = メンバ変数、name = 引数
    }

    public String getName() {
        return name;
    }

    public static void main(String[] args) {
        ThisDemo obj = new ThisDemo();
        obj.setName("田中");
        System.out.println(obj.getName());  // 田中
    }
}</code></pre>
                </div>
                <div class="syntax-box">
                    <div class="syntax-box-header">
                        <span class="syntax-box-icon"><span class="material-icons">menu_book</span></span>
                        <span class="syntax-box-title">構文説明</span>
                    </div>
                    <div class="syntax-box-content">
                        <div class="syntax-item">
                            <h4>thisキーワード</h4>
                            <div class="syntax-pattern">this.メンバ変数名</div>
                            <p>thisは現在のインスタンスへの参照です。メソッドの引数とフィールドの名前が同じ場合、thisを使ってフィールドを明示的に参照します。</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- セクション 5-3 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Section 5-3</span>
                <h2 class="section-title">オブジェクトの生成とアクセス</h2>
            </div>

            <div class="intro-text">
                <p>クラスは設計図に過ぎず、実際に使うにはnewキーワードでオブジェクト（インスタンス）を生成する必要があります。生成されたオブジェクトを通じて、フィールドやメソッドにアクセスします。Spring Frameworkでは、このオブジェクト生成をフレームワークが自動的に行う「DI（依存性注入）」という仕組みを使います。</p>
            </div>

            <div class="prompt-box">
                <div class="prompt-box-header">
                    <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                    <span class="prompt-box-title">プロンプト</span>
                    <button class="prompt-copy-btn">コピー</button>
                </div>
                <div class="prompt-box-content">
                    <pre><code>## 機能
Personクラスのインスタンス生成とメソッド呼び出しを確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter05
- ファイル名: PersonMain.java

## 実装要件
- newキーワードでPersonオブジェクトを生成する
- コンストラクタに名前と年齢を渡す
- introduce()メソッドを呼び出す
- getterでフィールド値を取得する


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする

## 使用するJava構文
- newキーワードによるインスタンス化
- コンストラクタ呼び出し
- メソッド呼び出し（ドット演算子）</code></pre>
                </div>
            </div>
            <div class="code-block">
                <div class="code-header"><span class="code-title">chapter05/PersonMain.java</span><span class="code-lang">Java</span></div>
                <pre class="code-content"><code>public class PersonMain {
    public static void main(String[] args) {
        // オブジェクトの生成
        Person person = new Person("田中", 25);

        // メンバへのアクセス
        person.introduce();  // メソッド呼び出し
        String name = person.getName();  // getter
    }
}</code></pre>
            </div>
            <div class="syntax-box">
                <div class="syntax-box-header">
                    <span class="syntax-box-icon"><span class="material-icons">menu_book</span></span>
                    <span class="syntax-box-title">構文説明</span>
                </div>
                <div class="syntax-box-content">
                    <div class="syntax-item">
                        <h4>インスタンス化（オブジェクト生成）</h4>
                        <div class="syntax-pattern">クラス名 変数名 = new クラス名(引数);</div>
                        <p>newキーワードでクラスからオブジェクト（インスタンス）を生成します。コンストラクタが呼び出され、フィールドが初期化されます。</p>
                    </div>
                    <div class="syntax-item">
                        <h4>Getter（取得メソッド）</h4>
                        <div class="syntax-pattern">public 型 getフィールド名() { return this.フィールド名; }</div>
                        <p>privateフィールドの値を外部から取得するためのメソッドです。カプセル化を維持しながらフィールド値を参照できます。</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- セクション 5-4 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Section 5-4</span>
                <h2 class="section-title">アクセス修飾子の使用</h2>
            </div>

            <div class="intro-text">
                <p>アクセス修飾子は「どこからアクセスできるか」を制御します。適切なアクセス制御により、クラスの内部実装を隠蔽し、外部には必要なインターフェースだけを公開できます。これがカプセル化の基本であり、バグの防止とコードの保守性向上に直結します。</p>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">4.1 アクセス修飾子</h3>
                <table class="data-table">
                    <thead>
                        <tr><th>修飾子</th><th>同クラス</th><th>同パッケージ</th><th>サブクラス</th><th>全て</th></tr>
                    </thead>
                    <tbody>
                        <tr><td><code>public</code></td><td>○</td><td>○</td><td>○</td><td>○</td></tr>
                        <tr><td><code>protected</code></td><td>○</td><td>○</td><td>○</td><td>×</td></tr>
                        <tr><td>（なし）</td><td>○</td><td>○</td><td>×</td><td>×</td></tr>
                        <tr><td><code>private</code></td><td>○</td><td>×</td><td>×</td><td>×</td></tr>
                    </tbody>
                </table>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">4.2 カプセル化</h3>
                <div class="content-block">
                    <p>フィールドをprivateにし、getter/setterでアクセスを制御します。</p>
                    <div class="prompt-box">
                        <div class="prompt-box-header">
                            <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                            <span class="prompt-box-title">プロンプト</span>
                            <button class="prompt-copy-btn">コピー</button>
                        </div>
                        <div class="prompt-box-content">
                            <pre><code>## 機能
カプセル化を実装した銀行口座クラスの動作を確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter05
- ファイル名: BankAccount.java

## 実装要件
- 残高(balance)をprivateフィールドで保護する
- getBalance()で残高を取得できるようにする
- deposit()で入金処理を行い、不正な値（0以下）は拒否する
- フィールドへの直接アクセスを禁止し、メソッド経由でのみ操作可能にする


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする

## 使用するJava構文
- privateアクセス修飾子
- getterメソッド
- 入力値の検証（if文）</code></pre>
                        </div>
                    </div>
                    <div class="code-block">
                        <div class="code-header"><span class="code-title">chapter05/BankAccount.java</span><span class="code-lang">Java</span></div>
                        <pre class="code-content"><code>public class BankAccount {
    private int balance;  // privateで保護

    public int getBalance() {  // getter
        return balance;
    }

    public void deposit(int amount) {  // setter的役割
        if (amount > 0) {
            balance += amount;
        }
    }

    public static void main(String[] args) {
        BankAccount account = new BankAccount();
        account.deposit(1000);
        System.out.println("残高: " + account.getBalance());  // 残高: 1000
        account.deposit(-500);  // 不正な値は拒否される
        System.out.println("残高: " + account.getBalance());  // 残高: 1000
    }
}</code></pre>
                    </div>
                    <div class="syntax-box">
                        <div class="syntax-box-header">
                            <span class="syntax-box-icon"><span class="material-icons">menu_book</span></span>
                            <span class="syntax-box-title">構文説明</span>
                        </div>
                        <div class="syntax-box-content">
                            <div class="syntax-item">
                                <h4>Getter / Setter</h4>
                                <div class="syntax-pattern">public 型 getフィールド名() {
  return this.フィールド名;
}

public void setフィールド名(型 値) {
  this.フィールド名 = 値;
}</div>
                                <p>Getterはprivateフィールドの値を取得し、Setterは値を設定します。Setter内でバリデーション（値の検証）を行うことで、不正な値の設定を防げます。</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- セクション 5-5 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Section 5-5</span>
                <h2 class="section-title">メソッドのオーバーロード</h2>
            </div>

            <div class="intro-text">
                <p>オーバーロードにより、同じ処理を異なる引数で呼び出せる柔軟なAPIを設計できます。例えば、System.out.println()はint、String、doubleなど様々な型を受け取れますが、これはオーバーロードで実現されています。利用者にとって直感的なインターフェースを提供できます。</p>
            </div>

            <div class="content-block">
                <p>同じ名前で引数の型や数が異なるメソッドを定義できます。</p>
                <div class="prompt-box">
                    <div class="prompt-box-header">
                        <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                        <span class="prompt-box-title">プロンプト</span>
                        <button class="prompt-copy-btn">コピー</button>
                    </div>
                    <div class="prompt-box-content">
                        <pre><code>## 機能
メソッドのオーバーロードの動作を確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter05
- ファイル名: Printer.java

## 実装要件
- print()メソッドを複数定義する
- int型を受け取るprint()を実装
- String型を受け取るprint()を実装
- 2つのint型を受け取るprint()を実装
- 同じメソッド名で引数の型や数が異なることを示す


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする

## 使用するJava構文
- メソッドのオーバーロード
- 同一メソッド名、異なるシグネチャ</code></pre>
                    </div>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-title">chapter05/Printer.java</span><span class="code-lang">Java</span></div>
                    <pre class="code-content"><code>public class Printer {
    public void print(int value) {
        System.out.println("整数: " + value);
    }

    public void print(String value) {
        System.out.println("文字列: " + value);
    }

    public void print(int a, int b) {
        System.out.println("2つの整数: " + a + ", " + b);
    }

    public static void main(String[] args) {
        Printer printer = new Printer();
        printer.print(42);          // 整数: 42
        printer.print("Hello");     // 文字列: Hello
        printer.print(10, 20);      // 2つの整数: 10, 20
    }
}</code></pre>
                </div>
                <div class="syntax-box">
                    <div class="syntax-box-header">
                        <span class="syntax-box-icon"><span class="material-icons">menu_book</span></span>
                        <span class="syntax-box-title">構文説明</span>
                    </div>
                    <div class="syntax-box-content">
                        <div class="syntax-item">
                            <h4>オーバーロード（多重定義）</h4>
                            <div class="syntax-pattern">同じメソッド名(異なる引数リスト) { }</div>
                            <p>同じ名前のメソッドを、引数の型・数・順序を変えて複数定義することです。呼び出し時の引数に応じて適切なメソッドが選択されます。戻り値の型だけが異なる場合はオーバーロードできません。</p>
                        </div>
                    </div>
                </div>
                <div class="warning-box">
                    <div class="warning-box-header"><span class="warning-box-icon"><span class="material-icons">warning</span></span><span class="warning-box-title">注意</span></div>
                    <p>戻り値の型だけが異なるメソッドはオーバーロードできません。引数リストが異なる必要があります。</p>
                </div>
            </div>
        </section>

        <!-- セクション 5-6 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Section 5-6</span>
                <h2 class="section-title">オブジェクトの初期化</h2>
            </div>

            <div class="intro-text">
                <p>コンストラクタはオブジェクト生成時に自動的に呼ばれる特別なメソッドで、フィールドの初期化を担当します。適切なコンストラクタ設計により、「生成した時点で使える状態」のオブジェクトを保証できます。これは不正な状態のオブジェクトが存在することを防ぎます。</p>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">6.2 コンストラクタ</h3>
                <div class="prompt-box">
                    <div class="prompt-box-header">
                        <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                        <span class="prompt-box-title">プロンプト</span>
                        <button class="prompt-copy-btn">コピー</button>
                    </div>
                    <div class="prompt-box-content">
                        <pre><code>## 機能
複数のコンストラクタを持つPersonクラスの動作を確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter05
- ファイル名: PersonConstructor.java

## 実装要件
- privateフィールドとしてnameとageを持つ
- 引数付きコンストラクタで名前と年齢を初期化
- デフォルトコンストラクタでデフォルト値を設定
- this()を使って他のコンストラクタを呼び出す


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする

## 使用するJava構文
- コンストラクタ（クラス名と同名、戻り値なし）
- コンストラクタのオーバーロード
- this()によるコンストラクタチェーン</code></pre>
                    </div>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-title">chapter05/PersonConstructor.java</span><span class="code-lang">Java</span></div>
                    <pre class="code-content"><code>public class PersonConstructor {
    private String name;
    private int age;

    // コンストラクタ（クラス名と同じ、戻り値なし）
    public PersonConstructor(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // デフォルトコンストラクタ
    public PersonConstructor() {
        this("Unknown", 0);  // 他のコンストラクタを呼び出し
    }

    public static void main(String[] args) {
        PersonConstructor p1 = new PersonConstructor("田中", 25);
        PersonConstructor p2 = new PersonConstructor();
        System.out.println(p1.name + " / " + p1.age);  // 田中 / 25
        System.out.println(p2.name + " / " + p2.age);  // Unknown / 0
    }
}</code></pre>
                </div>
                <div class="syntax-box">
                    <div class="syntax-box-header">
                        <span class="syntax-box-icon"><span class="material-icons">menu_book</span></span>
                        <span class="syntax-box-title">構文説明</span>
                    </div>
                    <div class="syntax-box-content">
                        <div class="syntax-item">
                            <h4>コンストラクタ</h4>
                            <div class="syntax-pattern">public クラス名(引数リスト) { 初期化処理 }</div>
                            <p>オブジェクト生成時に自動的に呼び出され、フィールドの初期化を行います。クラス名と同じ名前で、戻り値の型は書きません。</p>
                        </div>
                        <div class="syntax-item">
                            <h4>コンストラクタのオーバーロード</h4>
                            <div class="syntax-pattern">this(引数);</div>
                            <p>同じクラス内の別のコンストラクタを呼び出します。this()はコンストラクタの最初の行に記述する必要があります。</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">6.3 デフォルトコンストラクタ</h3>
                <div class="info-box">
                    <div class="info-box-header"><span class="info-box-icon"><span class="material-icons">lightbulb</span></span><span class="info-box-title">デフォルトコンストラクタ</span></div>
                    <p>コンストラクタを1つも定義しない場合、引数なしのデフォルトコンストラクタが自動生成されます。1つでもコンストラクタを定義すると、自動生成されません。</p>
                </div>
            </div>
        </section>

        <!-- セクション 5-7 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Section 5-7</span>
                <h2 class="section-title">static変数とstaticメソッド</h2>
            </div>

            <div class="intro-text">
                <p>staticメンバは「クラス全体で共有される」データや処理を定義します。全インスタンスで共通のカウンターや、ユーティリティメソッド（Math.max()など）の実装に使われます。ただし、staticの多用はテストしにくいコードになりやすいため、適切な使い分けが重要です。</p>
            </div>

            <div class="content-block">
                <p><code>static</code>メンバはクラスに属し、インスタンスを作成せずにアクセスできます。</p>
                <div class="prompt-box">
                    <div class="prompt-box-header">
                        <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                        <span class="prompt-box-title">プロンプト</span>
                        <button class="prompt-copy-btn">コピー</button>
                    </div>
                    <div class="prompt-box-content">
                        <pre><code>## 機能
static変数とstaticメソッドを使ったカウンタークラスの動作を確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter05
- ファイル名: Counter.java

## 実装要件
- static変数countで全インスタンス共通のカウントを管理
- コンストラクタでインスタンス生成時にcountを増加
- staticメソッドgetCount()でカウント値を取得
- クラス名から直接メソッドを呼び出す使用例も含める


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする

## 使用するJava構文
- static変数（クラス変数）
- staticメソッド（クラスメソッド）
- クラス名.メソッド名()による呼び出し</code></pre>
                    </div>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-title">chapter05/Counter.java</span><span class="code-lang">Java</span></div>
                    <pre class="code-content"><code>public class Counter {
    private static int count = 0;  // クラス変数

    public Counter() {
        count++;  // インスタンス生成ごとにカウント
    }

    public static int getCount() {  // クラスメソッド
        return count;
    }

    public static void main(String[] args) {
        Counter c1 = new Counter();
        Counter c2 = new Counter();
        System.out.println(Counter.getCount());  // 2
    }
}</code></pre>
                </div>
                <div class="syntax-box">
                    <div class="syntax-box-header">
                        <span class="syntax-box-icon"><span class="material-icons">menu_book</span></span>
                        <span class="syntax-box-title">構文説明</span>
                    </div>
                    <div class="syntax-box-content">
                        <div class="syntax-item">
                            <h4>static変数（クラス変数）</h4>
                            <div class="syntax-pattern">static 型 変数名;</div>
                            <p>インスタンスではなくクラスに属する変数です。すべてのインスタンスで共有され、クラス名.変数名でアクセスできます。</p>
                        </div>
                        <div class="syntax-item">
                            <h4>staticメソッド（クラスメソッド）</h4>
                            <div class="syntax-pattern">public static 戻り値型 メソッド名() { }</div>
                            <p>インスタンスを生成せずにクラス名.メソッド名()で呼び出せるメソッドです。staticメソッド内ではthisや非staticメンバにアクセスできません。</p>
                        </div>
                    </div>
                </div>
                <div class="warning-box">
                    <div class="warning-box-header"><span class="warning-box-icon"><span class="material-icons">warning</span></span><span class="warning-box-title">staticメソッドの制限</span></div>
                    <p>staticメソッド内では、thisキーワードや非staticメンバに直接アクセスできません。</p>
                </div>
            </div>
        </section>

        <!-- セクション 5-8 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Section 5-8</span>
                <h2 class="section-title">オブジェクトの扱い</h2>
            </div>

            <div class="intro-text">
                <p>Javaでは、基本データ型は「値」がコピーされますが、オブジェクトは「参照（アドレス）」がコピーされます。この違いを理解していないと、意図しないデータ変更が起きるバグの原因になります。また、ガベージコレクションの仕組みを知ることで、メモリ管理への理解が深まります。</p>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">8.1 値のコピーと参照情報のコピー</h3>
                <div class="prompt-box">
                    <div class="prompt-box-header">
                        <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                        <span class="prompt-box-title">プロンプト</span>
                        <button class="prompt-copy-btn">コピー</button>
                    </div>
                    <div class="prompt-box-content">
                        <pre><code>## 機能
オブジェクトの参照コピーの動作を確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter05
- ファイル名: ReferenceDemo.java

## 実装要件
- Personオブジェクトを生成する
- 別の変数に参照をコピーする
- コピー先で値を変更するとコピー元も変わることを示す
- 参照型の変数が同じオブジェクトを指すことを説明
- 1ファイルで完結するよう、必要なクラスをすべて含める


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする

## 使用するJava構文
- 参照型変数の代入
- 同一オブジェクトへの複数参照
- setterによる値の変更</code></pre>
                    </div>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-title">chapter05/ReferenceDemo.java</span><span class="code-lang">Java</span></div>
                    <pre class="code-content"><code>class RefPerson {
    private String name;
    public RefPerson(String name) { this.name = name; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
}

public class ReferenceDemo {
    public static void main(String[] args) {
        RefPerson p1 = new RefPerson("Alice");
        RefPerson p2 = p1;  // 参照のコピー（同じオブジェクトを指す）

        System.out.println("変更前 p1: " + p1.getName());  // Alice
        p2.setName("Bob");
        System.out.println("変更後 p1: " + p1.getName());  // Bob（p1も変更される）
        System.out.println("p1 == p2: " + (p1 == p2));     // true（同じオブジェクト）
    }
}</code></pre>
                </div>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">8.2 ガベージコレクション</h3>
                <div class="content-block">
                    <p>どこからも参照されなくなったオブジェクトは、ガベージコレクタによって自動的にメモリから解放されます。</p>
                </div>
            </div>
        </section>

        <!-- 練習問題・解答 -->
        <section class="section">
            <div class="section-header"><span class="section-number">Exercise</span><h2 class="section-title">5章 練習問題</h2></div>
            <div class="exercise-list">
                <div class="exercise-item">
                    <div class="exercise-number">Q1</div>
                    <div class="exercise-content">
                        <p>staticメソッド内で使用できないものはどれですか？</p>
                        <ol type="A"><li>staticフィールド</li><li>this</li><li>ローカル変数</li><li>staticメソッド</li></ol>
                    </div>
                </div>
            </div>
        </section>

        <section class="section">
            <div class="section-header"><span class="section-number">Answer</span><h2 class="section-title">5章 解説・解答</h2></div>
            <div class="answer-list">
                <div class="answer-item">
                    <div class="answer-header">Q1の解答: B</div>
                    <div class="answer-content"><p>staticメソッドはインスタンスに属さないため、thisキーワードは使用できません。</p></div>
                </div>
            </div>
        </section>
    </div>

    <footer class="footer"><p>Java Silver 試験対策 教科書</p></footer>

    <div class="page-nav">
        <a href="4java-loop.html" class="page-nav-btn prev"><span>&#8592;</span><div><div class="page-nav-label">前の章</div><div class="page-nav-title">第4章</div></div></a>
        <a href="6java-inheritance.html" class="page-nav-btn next"><div><div class="page-nav-label">次の章</div><div class="page-nav-title">第6章</div></div><span>&#8594;</span></a>
    </div>

    <script>
        function toggleMenu() {
            const toggle = document.querySelector('.nav-toggle');
            const menu = document.querySelector('.nav-menu');
            toggle.classList.toggle('active');
            menu.classList.toggle('active');
        }
        document.addEventListener('click', function(e) {
            const nav = document.querySelector('.global-nav');
            const toggle = document.querySelector('.nav-toggle');
            const menu = document.querySelector('.nav-menu');
            if (!nav.contains(e.target) && menu.classList.contains('active')) {
                toggle.classList.remove('active');
                menu.classList.remove('active');
            }
        });
    </script>
    <script src="../../shared/demo.js"></script>
</body>
</html>
