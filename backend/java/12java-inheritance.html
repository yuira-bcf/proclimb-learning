<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第12章 継承</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700;900&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../../shared/common.css">
    <style>
      :root {
        --primary: #0097A7;
        --primary-dark: #00838F;
        --primary-light: #E0F7FA;
        --primary-lighter: #B2EBF2;
      }
      .nav-category-links { display: none; }
    </style>
</head>
<body>
    <nav class="global-nav"></nav>
    <script src="../../shared/js/nav-java.js"></script>

    <div class="container">
        <header class="chapter-header">
            <div class="chapter-badge"><span class="material-icons">menu_book</span> Chapter</div>
            <div class="chapter-number">12</div>
            <h1 class="chapter-title">継承</h1>
        </header>

        <nav class="toc">
            <h2 class="toc-title"><span class="material-icons">list_alt</span> この章の内容</h2>
            <ul class="toc-list">
                <li class="toc-item"><span class="toc-number">12-1</span><span>継承</span></li>
                <li class="toc-item"><span class="toc-number">12-2</span><span>メソッドのオーバーライド</span></li>
                <li class="toc-item"><span class="toc-number">12-3</span><span>継承関係におけるコンストラクタ</span></li>
                <li class="toc-item"><span class="toc-number">12-4</span><span>Objectクラスとレコードクラス</span></li>
            </ul>
        </nav>

        <!-- セクション 12-1 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Section 12-1</span>
                <h2 class="section-title">継承</h2>
            </div>

            <!-- 概要 -->
            <div class="intro-text">
                <p>継承はオブジェクト指向の重要な概念で、既存のクラスを拡張して新しいクラスを作る仕組みです。コードの再利用性を高め、「is-a関係」（DogはAnimalである）を表現できます。Spring Frameworkでも、多くのクラスが継承を活用して設計されています。</p>
            </div>

            <!-- 説明 -->
            <div class="content-block">
                <p>継承により、既存クラスの機能を引き継いだ新しいクラスを作成できます。</p>
                <ul class="bullet-list">
                    <li><strong>コードの再利用</strong>：親クラスに共通処理を書けば、子クラスで同じコードを書く必要がありません。</li>
                    <li><strong>拡張性</strong>：親クラスを変更すれば、すべての子クラスに反映されます。</li>
                    <li><strong>is-a関係</strong>：「DogはAnimalである」という現実世界の関係をそのままコードで表現できます。</li>
                </ul>
            </div>

            <!-- 図解 -->
            <div class="content-block">
                <div class="figure" style="margin: 20px 0;">
                    <div class="figure-caption">継承の全体像 ― 親クラスの機能を子クラスが引き継ぐ</div>
                    <svg viewBox="0 0 700 490" style="max-width: 700px; width: 100%; height: auto;">
                        <!-- ===== 親クラス Animal ===== -->
                        <rect x="175" y="10" width="350" height="210" rx="14" fill="#e0f2fe" stroke="#0ea5e9" stroke-width="2.5"/>
                        <rect x="175" y="10" width="350" height="40" rx="14" fill="#0ea5e9"/>
                        <rect x="175" y="36" width="350" height="14" fill="#0ea5e9"/>
                        <text x="350" y="36" text-anchor="middle" font-size="15" font-weight="700" fill="white">Animal（親クラス）</text>
                        <!-- フィールド -->
                        <text x="200" y="80" font-size="12" font-weight="600" fill="#0284c7">フィールド</text>
                        <rect x="200" y="90" width="300" height="30" rx="6" fill="white" stroke="#bae6fd" stroke-width="1"/>
                        <text x="350" y="110" text-anchor="middle" font-size="13" fill="#1e293b" font-family="monospace">protected String name</text>
                        <!-- メソッド -->
                        <text x="200" y="148" font-size="12" font-weight="600" fill="#0284c7">メソッド</text>
                        <rect x="200" y="158" width="300" height="30" rx="6" fill="white" stroke="#bae6fd" stroke-width="1"/>
                        <text x="350" y="178" text-anchor="middle" font-size="13" fill="#1e293b" font-family="monospace">void eat()</text>

                        <!-- ===== extends 矢印（左：Dog） ===== -->
                        <line x1="350" y1="220" x2="350" y2="250" stroke="#0ea5e9" stroke-width="2"/>
                        <line x1="350" y1="250" x2="130" y2="250" stroke="#0ea5e9" stroke-width="2"/>
                        <line x1="130" y1="250" x2="130" y2="325" stroke="#0ea5e9" stroke-width="2" marker-end="url(#arrowInherit)"/>
                        <!-- extends 矢印（右：Cat） -->
                        <line x1="350" y1="250" x2="570" y2="250" stroke="#0ea5e9" stroke-width="2"/>
                        <line x1="570" y1="250" x2="570" y2="325" stroke="#0ea5e9" stroke-width="2" marker-end="url(#arrowInherit)"/>
                        <!-- extends ラベル -->
                        <rect x="300" y="238" width="100" height="24" rx="6" fill="#0ea5e9"/>
                        <text x="350" y="255" text-anchor="middle" font-size="12" font-weight="700" fill="white">extends</text>

                        <!-- ===== 子クラス Dog ===== -->
                        <rect x="20" y="330" width="220" height="120" rx="14" fill="#fef3c7" stroke="#f59e0b" stroke-width="2"/>
                        <rect x="20" y="330" width="220" height="36" rx="14" fill="#f59e0b"/>
                        <rect x="20" y="352" width="220" height="14" fill="#f59e0b"/>
                        <text x="130" y="354" text-anchor="middle" font-size="14" font-weight="700" fill="white">Dog（子クラス）</text>
                        <text x="40" y="384" font-size="11" fill="#92400e">継承した機能</text>
                        <text x="40" y="402" font-size="12" fill="#64748b" font-family="monospace">name, eat()</text>
                        <text x="40" y="424" font-size="11" font-weight="600" fill="#92400e">独自メソッド</text>
                        <text x="40" y="442" font-size="12" fill="#1e293b" font-family="monospace">void bark()</text>

                        <!-- ===== 子クラス Cat ===== -->
                        <rect x="460" y="330" width="220" height="120" rx="14" fill="#d1fae5" stroke="#10b981" stroke-width="2"/>
                        <rect x="460" y="330" width="220" height="36" rx="14" fill="#10b981"/>
                        <rect x="460" y="352" width="220" height="14" fill="#10b981"/>
                        <text x="570" y="354" text-anchor="middle" font-size="14" font-weight="700" fill="white">Cat（子クラス）</text>
                        <text x="480" y="384" font-size="11" fill="#065f46">継承した機能</text>
                        <text x="480" y="402" font-size="12" fill="#64748b" font-family="monospace">name, eat()</text>
                        <text x="480" y="424" font-size="11" font-weight="600" fill="#065f46">独自メソッド</text>
                        <text x="480" y="442" font-size="12" fill="#1e293b" font-family="monospace">void meow()</text>

                        <!-- ===== is-a ラベル ===== -->
                        <rect x="240" y="458" width="220" height="28" rx="8" fill="#fefce8" stroke="#fbbf24" stroke-width="1"/>
                        <text x="350" y="477" text-anchor="middle" font-size="12" font-weight="600" fill="#854d0e">Dog is-a Animal / Cat is-a Animal</text>

                        <defs>
                            <marker id="arrowInherit" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                                <path d="M 0 0 L 10 5 L 0 10 z" fill="#0ea5e9"/>
                            </marker>
                        </defs>
                    </svg>
                </div>

            </div>

            <!-- プロンプト -->
            <div class="prompt-box">
                        <div class="prompt-box-header">
                            <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                            <span class="prompt-box-title">プロンプト</span>
                            <button class="prompt-copy-btn">コピー</button>
                        </div>
                        <div class="prompt-box-content">
                            <pre><code>## 機能
継承を使った動物クラスの階層の動作を確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter06
- ファイル名: InheritanceDemo.java

## 実装要件
- 親クラス(Animal)にprotectedフィールドnameを定義
- 親クラスにeat()メソッドを実装
- 子クラス(Dog)がAnimalをextendsで継承し、独自のbark()メソッドを追加
- 子クラス(Cat)がAnimalをextendsで継承し、独自のmeow()メソッドを追加
- 各子クラスから親クラスのフィールド・メソッドにアクセスできることを確認


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする
- 1ファイルで完結するよう、必要なクラスをすべて含める

## 使用するJava構文
- extends による継承
- protectedアクセス修飾子
- スーパークラスとサブクラスの関係（is-a関係）</code></pre>
                        </div>
                    </div>
                    <div class="code-block">
                        <div class="code-header"><span class="code-title">chapter06/InheritanceDemo.java</span><span class="code-lang">Java</span></div>
                        <pre class="code-content"><code>// スーパークラス（親クラス）
class Animal {
    protected String name;

    public void eat() {
        System.out.println(name + "が食事中");
    }
}

// サブクラス（子クラス）― Dog is-a Animal
class Dog extends Animal {
    public void bark() {
        System.out.println(name + "がワンワン！");
    }
}

// サブクラス（子クラス）― Cat is-a Animal
class Cat extends Animal {
    public void meow() {
        System.out.println(name + "がニャー！");
    }
}

// 実行用メインクラス
public class InheritanceDemo {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.name = "ポチ";
        dog.eat();   // ポチが食事中（Animalから継承）
        dog.bark();  // ポチがワンワン！（Dog独自）

        Cat cat = new Cat();
        cat.name = "タマ";
        cat.eat();   // タマが食事中（Animalから継承）
        cat.meow();  // タマがニャー！（Cat独自）
    }
}</code></pre>
            </div>

            <!-- 構文 -->
            <div class="syntax-box">
                <div class="syntax-box-header">
                    <span class="syntax-box-icon"><span class="material-icons">menu_book</span></span>
                    <span class="syntax-box-title">構文説明</span>
                </div>
                <div class="syntax-box-content">
                    <div class="syntax-item">
                        <h4>継承（extends）</h4>
                        <div class="syntax-pattern">class サブクラス extends スーパークラス { }</div>
                        <p>extendsキーワードで既存のクラス（スーパークラス）を継承し、新しいクラス（サブクラス）を定義します。サブクラスはスーパークラスのフィールドとメソッドを引き継ぎます。</p>
                    </div>
                    <div class="syntax-item">
                        <h4>protected修飾子</h4>
                        <div class="syntax-pattern">protected 型 変数名;</div>
                        <p>同じパッケージ内およびサブクラスからアクセス可能なアクセス修飾子です。継承関係でフィールドを共有したい場合に使用します。</p>
                    </div>
                </div>
            </div>

            <!-- 解説 -->
            <div class="info-box">
                <div class="info-box-header"><span class="info-box-icon"><span class="material-icons">lightbulb</span></span><span class="info-box-title">Javaの継承</span></div>
                <p>Javaは単一継承のみ対応。1つのクラスは1つのクラスしか継承できません。複数の機能を持たせたい場合はインタフェースを使用します。</p>
            </div>

            <!-- 実際のユースケース -->
            <div class="info-box">
                <div class="info-box-header"><span class="info-box-icon"><span class="material-icons">work</span></span><span class="info-box-title">実際のユースケース</span></div>
                <ul class="bullet-list">
                    <li><strong>Spring Boot のコントローラ</strong>：共通のバリデーションやエラーハンドリングを親クラス（BaseController）にまとめ、各画面のコントローラが継承して個別処理だけを記述します。</li>
                    <li><strong>例外クラスの階層</strong>：<code>RuntimeException</code> を継承して <code>UserNotFoundException</code> や <code>InvalidOrderException</code> など業務固有の例外を定義し、エラー処理を整理します。</li>
                    <li><strong>JPA エンティティの共通フィールド</strong>：<code>createdAt</code>、<code>updatedAt</code> などの監査フィールドを親クラス（BaseEntity）に定義し、全テーブルのエンティティで継承して共通化します。</li>
                </ul>
            </div>

            <!-- 基礎問題 -->
            <div class="subsection">
                <h3 class="subsection-title">基礎問題</h3>
                <div class="content-block">
                    <p>学んだ継承の仕組みを使って、<strong>乗り物の管理プログラム</strong>を作ってみましょう。親クラス「Vehicle」を作成し、子クラス「Car」「Motorcycle」がそれを継承する構成です。</p>
                </div>
                <div class="exercise-list">
                    <div class="exercise-item">
                        <div class="exercise-number">Q</div>
                        <div class="exercise-content">
                            <p>以下の要件を満たすプログラムを、下のプロンプトを使って作成してください。</p>
                            <ul class="bullet-list">
                                <li>「乗り物」の親クラスに名前と情報表示の機能を持たせる</li>
                                <li>「車」は乗り物の仲間で、ドアの数とクラクション機能を追加する</li>
                                <li>「バイク」も乗り物の仲間で、種類とエンジンふかし機能を追加する</li>
                                <li>車とバイクの両方で、親の情報表示が使えることを確認する</li>
                            </ul>
                        </div>
                    </div>
                </div>
                <!-- プロンプト -->
                <div class="prompt-box">
                    <div class="prompt-box-header">
                        <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                        <span class="prompt-box-title">基礎問題プロンプト</span>
                        <button class="prompt-copy-btn">コピー</button>
                    </div>
                    <div class="prompt-box-content">
                        <pre><code>## 作りたいもの
乗り物の情報を表示するプログラム

## 生成先
- ディレクトリ: chapter06
- ファイル名: VehicleDemo.java

## やりたいこと
- 「乗り物」という共通のグループを作る
  - 名前の情報を持つ（子のグループからも使えるようにする）
  - 「乗り物: ○○」と名前を画面に表示する機能を持つ
- 「車」は「乗り物」の仲間として作る
  - ドアの数の情報を追加で持つ
  - クラクションを鳴らす機能を追加する（「○○のクラクション: ブーブー！」と表示）
- 「バイク」も「乗り物」の仲間として作る
  - バイクの種類（スポーツ／スクーターなど）の情報を追加で持つ
  - エンジンをふかす機能を追加する（「○○のエンジン: ブロロロ！」と表示）

## 動かし方
- 車を1台作って名前を「プリウス」、ドアの数を4にして、情報表示とクラクションを実行
- バイクを1台作って名前を「CBR250R」、種類を「スポーツ」にして、情報表示とエンジンふかしを実行
- 全ての結果を画面に表示する
- 1つのファイルにすべてまとめる</code></pre>
                    </div>
                </div>
                <!-- サンプルソースコード -->
                <div class="code-block">
                    <div class="code-header"><span class="code-title">chapter06/VehicleDemo.java（解答例）</span><span class="code-lang">Java</span></div>
                    <pre class="code-content"><code>// 親クラス（乗り物）
class Vehicle {
    protected String name;

    public void showInfo() {
        System.out.println("乗り物: " + name);
    }
}

// 子クラス（車）― Car is-a Vehicle
class Car extends Vehicle {
    protected int doorCount;

    public void honk() {
        System.out.println(name + "のクラクション: ブーブー！");
    }
}

// 子クラス（バイク）― Motorcycle is-a Vehicle
class Motorcycle extends Vehicle {
    protected String bikeType;

    public void revEngine() {
        System.out.println(name + "のエンジン: ブロロロ！");
    }
}

public class VehicleDemo {
    public static void main(String[] args) {
        Car car = new Car();
        car.name = "プリウス";
        car.doorCount = 4;
        car.showInfo();       // 乗り物: プリウス（Vehicleから継承）
        car.honk();           // プリウスのクラクション: ブーブー！（Car独自）

        Motorcycle moto = new Motorcycle();
        moto.name = "CBR250R";
        moto.bikeType = "スポーツ";
        moto.showInfo();      // 乗り物: CBR250R（Vehicleから継承）
        moto.revEngine();     // CBR250Rのエンジン: ブロロロ！（Motorcycle独自）
    }
}</code></pre>
                </div>
            </div>
        </section>

        <!-- セクション 12-2 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Section 12-2</span>
                <h2 class="section-title">メソッドのオーバーライド</h2>
            </div>

            <!-- 概要 -->
            <div class="intro-text">
                <p>オーバーライドは、親クラスのメソッドを子クラスで「上書き」する仕組みです。親と同じメソッド名で、子クラスごとに異なる処理を実装（ポリモーフィズム／多態性）できます。@Overrideアノテーションを付けることで、メソッド名のタイプミスをコンパイル時に検出できます。</p>
            </div>

            <!-- ========== 12-2-1 オーバーライド ========== -->
            <div class="subsection">
                <h3 class="subsection-title">12-2-1 オーバーライド</h3>
                <!-- 説明 -->
                <div class="content-block">
                    <p>親クラスに定義されたメソッドを、子クラスで<strong>同じ名前・同じ引数</strong>で書き直すことをオーバーライドと呼びます。子クラスのインスタンスでそのメソッドを呼ぶと、親ではなく<strong>子クラス側の処理が実行</strong>されます。</p>
                </div>
                <!-- 図解 -->
                <div class="figure" style="margin: 20px 0;">
                    <div class="figure-caption">オーバーライドの仕組み ― 親のメソッドを子が「上書き」する</div>
                    <svg viewBox="0 0 700 300" style="max-width: 700px; width: 100%; height: auto;">
                        <!-- ===== 親クラス Animal ===== -->
                        <rect x="230" y="10" width="240" height="100" rx="14" fill="#e0f2fe" stroke="#0ea5e9" stroke-width="2.5"/>
                        <rect x="230" y="10" width="240" height="36" rx="14" fill="#0ea5e9"/>
                        <rect x="230" y="32" width="240" height="14" fill="#0ea5e9"/>
                        <text x="350" y="34" text-anchor="middle" font-size="14" font-weight="700" fill="white">Animal（親クラス）</text>
                        <rect x="250" y="60" width="200" height="28" rx="6" fill="white" stroke="#bae6fd" stroke-width="1"/>
                        <text x="350" y="79" text-anchor="middle" font-size="13" fill="#1e293b" font-family="monospace">void speak()</text>
                        <text x="350" y="102" text-anchor="middle" font-size="11" fill="#64748b">出力: "動物の声"</text>
                        <!-- ===== extends 矢印 ===== -->
                        <line x1="350" y1="110" x2="350" y2="150" stroke="#0ea5e9" stroke-width="2" marker-end="url(#arrowOvr)"/>
                        <text x="380" y="136" font-size="11" font-weight="600" fill="#0ea5e9">extends</text>
                        <!-- ===== 子クラス Cat ===== -->
                        <rect x="230" y="150" width="240" height="100" rx="14" fill="#fef3c7" stroke="#f59e0b" stroke-width="2"/>
                        <rect x="230" y="150" width="240" height="36" rx="14" fill="#f59e0b"/>
                        <rect x="230" y="172" width="240" height="14" fill="#f59e0b"/>
                        <text x="350" y="174" text-anchor="middle" font-size="14" font-weight="700" fill="white">Cat（子クラス）</text>
                        <rect x="250" y="200" width="200" height="28" rx="6" fill="#fff7ed" stroke="#fb923c" stroke-width="1.5"/>
                        <text x="350" y="219" text-anchor="middle" font-size="13" fill="#9a3412" font-family="monospace">speak() を上書き</text>
                        <text x="350" y="244" text-anchor="middle" font-size="11" fill="#64748b">出力: "ニャー"（親の処理は実行されない）</text>
                        <!-- 注釈 -->
                        <rect x="490" y="190" width="200" height="50" rx="10" fill="#fefce8" stroke="#fbbf24" stroke-width="1"/>
                        <text x="590" y="212" text-anchor="middle" font-size="11" font-weight="600" fill="#854d0e">同じメソッド名・同じ引数</text>
                        <text x="590" y="230" text-anchor="middle" font-size="11" fill="#854d0e">→ 子の処理で上書きされる</text>
                        <defs>
                            <marker id="arrowOvr" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                                <path d="M 0 0 L 10 5 L 0 10 z" fill="#0ea5e9"/>
                            </marker>
                        </defs>
                    </svg>
                </div>
                <!-- プロンプト -->
                <div class="prompt-box">
                    <div class="prompt-box-header">
                        <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                        <span class="prompt-box-title">プロンプト</span>
                        <button class="prompt-copy-btn">コピー</button>
                    </div>
                    <div class="prompt-box-content">
                        <pre><code>## 機能
メソッドのオーバーライドとsuperキーワードの動作を確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter06
- ファイル名: OverrideDemo.java

## 実装要件
- 親クラス(Animal)にspeak()メソッドを定義
- 子クラス(Cat)でspeak()をオーバーライド
- @Overrideアノテーションを付ける
- super.speak()で親クラスのメソッドも呼び出す
- 子クラス独自の処理を追加


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする
- 1ファイルで完結するよう、必要なクラスをすべて含める

## 使用するJava構文
- @Overrideアノテーション
- メソッドのオーバーライド
- superキーワードで親メソッド呼び出し</code></pre>
                    </div>
                </div>
                <!-- ソースコード -->
                <div class="code-block">
                    <div class="code-header"><span class="code-title">chapter06/OverrideDemo.java</span><span class="code-lang">Java</span></div>
                    <pre class="code-content"><code>class Animal {
    public void speak() {
        System.out.println("動物の声");
    }
}

class Cat extends Animal {
    @Override
    public void speak() {
        super.speak();  // 親クラスのメソッドを呼び出し
        System.out.println("ニャー");
    }
}

public class OverrideDemo {
    public static void main(String[] args) {
        Cat cat = new Cat();
        cat.speak();
        // 出力: 動物の声
        //       ニャー
    }
}</code></pre>
                </div>
                <!-- 構文 -->
                <div class="syntax-box">
                    <div class="syntax-box-header">
                        <span class="syntax-box-icon"><span class="material-icons">menu_book</span></span>
                        <span class="syntax-box-title">構文説明</span>
                    </div>
                    <div class="syntax-box-content">
                        <div class="syntax-item">
                            <h4>オーバーライド</h4>
                            <div class="syntax-pattern">public 戻り値型 メソッド名(引数) { 新しい処理 }</div>
                            <p>親クラスと同じメソッド名・同じ引数で子クラスにメソッドを定義すると、親の処理が上書きされます。子クラスのインスタンスでそのメソッドを呼ぶと、子クラス側の処理が実行されます。</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ========== 12-2-2 super ========== -->
            <div class="subsection">
                <h3 class="subsection-title">12-2-2 super</h3>
                <!-- 説明 -->
                <div class="content-block">
                    <p>オーバーライドすると親の処理は上書きされますが、<code>super.メソッド名()</code>を使えば、上書き前の親クラスの処理も呼び出せます。「親の処理＋子の追加処理」という組み合わせが可能です。</p>
                </div>
                <!-- 図解 -->
                <div class="figure" style="margin: 20px 0;">
                    <div class="figure-caption">cat.speak() を呼んだときの実行フロー</div>
                    <svg viewBox="0 0 700 340" style="max-width: 700px; width: 100%; height: auto;">
                        <!-- ===== Step 1: 呼び出し ===== -->
                        <rect x="10" y="10" width="200" height="70" rx="12" fill="#1e293b"/>
                        <text x="110" y="36" text-anchor="middle" font-size="13" font-family="monospace" font-weight="700" fill="#67e8f9">cat.speak();</text>
                        <text x="110" y="58" text-anchor="middle" font-size="11" fill="#94a3b8">メソッド呼び出し</text>
                        <!-- 矢印 1→2 -->
                        <line x1="210" y1="45" x2="254" y2="45" stroke="#f59e0b" stroke-width="2" marker-end="url(#arrowFlow)"/>
                        <text x="232" y="38" text-anchor="middle" font-size="10" fill="#f59e0b">1</text>
                        <!-- ===== Step 2: Cat の speak() に入る ===== -->
                        <rect x="260" y="10" width="430" height="130" rx="12" fill="#fef3c7" stroke="#f59e0b" stroke-width="2"/>
                        <rect x="260" y="10" width="430" height="32" rx="12" fill="#f59e0b"/>
                        <rect x="260" y="30" width="430" height="12" fill="#f59e0b"/>
                        <text x="475" y="30" text-anchor="middle" font-size="13" font-weight="700" fill="white">Cat の speak()（オーバーライド済み）</text>
                        <!-- super.speak() 行 -->
                        <rect x="280" y="54" width="390" height="30" rx="6" fill="white" stroke="#fde68a" stroke-width="1"/>
                        <text x="290" y="74" font-size="12" font-family="monospace" fill="#0284c7" font-weight="600">super.speak();</text>
                        <text x="430" y="74" font-size="11" fill="#64748b">← 親のメソッドを呼ぶ</text>
                        <!-- println 行 -->
                        <rect x="280" y="94" width="390" height="30" rx="6" fill="white" stroke="#fde68a" stroke-width="1"/>
                        <text x="290" y="114" font-size="12" font-family="monospace" fill="#9a3412">System.out.println("ニャー");</text>
                        <!-- 矢印 super → Animal -->
                        <line x1="475" y1="84" x2="475" y2="170" stroke="#0ea5e9" stroke-width="2" stroke-dasharray="6,4"/>
                        <line x1="475" y1="170" x2="275" y2="170" stroke="#0ea5e9" stroke-width="2" stroke-dasharray="6,4" marker-end="url(#arrowFlow2)"/>
                        <text x="490" y="138" font-size="10" font-weight="600" fill="#0ea5e9">2</text>
                        <!-- ===== Step 3: Animal の speak() ===== -->
                        <rect x="10" y="156" width="260" height="60" rx="12" fill="#e0f2fe" stroke="#0ea5e9" stroke-width="2"/>
                        <rect x="10" y="156" width="260" height="30" rx="12" fill="#0ea5e9"/>
                        <rect x="10" y="174" width="260" height="12" fill="#0ea5e9"/>
                        <text x="140" y="174" text-anchor="middle" font-size="12" font-weight="700" fill="white">Animal の speak()（親）</text>
                        <text x="30" y="204" font-size="12" font-family="monospace" fill="#0c4a6e">println("動物の声");</text>
                        <!-- 矢印 Animal → 戻る -->
                        <line x1="270" y1="186" x2="380" y2="186" stroke="#0ea5e9" stroke-width="2" stroke-dasharray="6,4"/>
                        <line x1="380" y1="186" x2="380" y2="118" stroke="#0ea5e9" stroke-width="2" stroke-dasharray="6,4" marker-end="url(#arrowFlow2)"/>
                        <text x="330" y="180" font-size="10" font-weight="600" fill="#0ea5e9">3 戻る</text>
                        <!-- ===== 出力結果 ===== -->
                        <text x="10" y="250" font-size="13" font-weight="700" fill="#334155">実行結果（出力順）</text>
                        <rect x="10" y="260" width="680" height="70" rx="10" fill="#1e293b"/>
                        <text x="40" y="286" font-size="14" font-family="monospace" fill="#86efac">1行目: 動物の声</text>
                        <text x="280" y="286" font-size="11" fill="#64748b">← super.speak() の出力</text>
                        <text x="40" y="314" font-size="14" font-family="monospace" fill="#fbbf24">2行目: ニャー</text>
                        <text x="280" y="314" font-size="11" fill="#64748b">← Cat 独自の出力</text>
                        <defs>
                            <marker id="arrowFlow" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                                <path d="M 0 0 L 10 5 L 0 10 z" fill="#f59e0b"/>
                            </marker>
                            <marker id="arrowFlow2" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                                <path d="M 0 0 L 10 5 L 0 10 z" fill="#0ea5e9"/>
                            </marker>
                        </defs>
                    </svg>
                </div>
                <!-- 構文 -->
                <div class="syntax-box">
                    <div class="syntax-box-header">
                        <span class="syntax-box-icon"><span class="material-icons">menu_book</span></span>
                        <span class="syntax-box-title">構文説明</span>
                    </div>
                    <div class="syntax-box-content">
                        <div class="syntax-item">
                            <h4>super（親メソッド呼び出し）</h4>
                            <div class="syntax-pattern">super.メソッド名(引数);</div>
                            <p>superキーワードで親クラスのメソッドを呼び出せます。オーバーライドしたメソッド内で、親の処理も実行したい場合に使用します。</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ========== 12-2-3 @Overrideアノテーション ========== -->
            <div class="subsection">
                <h3 class="subsection-title">12-2-3 @Overrideアノテーション</h3>
                <!-- 説明 -->
                <div class="content-block">
                    <p><code>@Override</code>を付けると、正しくオーバーライドされているかコンパイラがチェックします。付けなくてもオーバーライド自体は動作しますが、タイプミスによるバグを防ぐために常に付けることが推奨されます。</p>
                </div>
                <!-- 図解 -->
                <div class="figure" style="margin: 20px 0;">
                    <div class="figure-caption">@Override を付けないと「タイプミスがバグになる」</div>
                    <svg viewBox="0 0 700 370" style="max-width: 700px; width: 100%; height: auto;">
                        <!-- ===== NG例（左） ===== -->
                        <text x="10" y="22" font-size="13" font-weight="700" fill="#dc2626">@Override なし ― タイプミスに気づけない</text>
                        <rect x="10" y="32" width="330" height="200" rx="10" fill="#1e293b"/>
                        <text x="28" y="58" font-size="12" font-family="monospace" fill="#94a3b8">class Animal {</text>
                        <text x="46" y="78" font-size="12" font-family="monospace" fill="#67e8f9">public void </text>
                        <text x="152" y="78" font-size="12" font-family="monospace" font-weight="700" fill="#fbbf24">speak</text>
                        <text x="192" y="78" font-size="12" font-family="monospace" fill="#94a3b8">() { ... }</text>
                        <text x="28" y="98" font-size="12" font-family="monospace" fill="#94a3b8">}</text>
                        <text x="28" y="128" font-size="12" font-family="monospace" fill="#94a3b8">class Cat extends Animal {</text>
                        <text x="46" y="148" font-size="12" font-family="monospace" fill="#94a3b8">// @Override がない！</text>
                        <text x="46" y="168" font-size="12" font-family="monospace" fill="#67e8f9">public void </text>
                        <text x="152" y="168" font-size="12" font-family="monospace" font-weight="700" fill="#f87171">spiak</text>
                        <text x="192" y="168" font-size="12" font-family="monospace" fill="#94a3b8">() { ... }</text>
                        <text x="46" y="188" font-size="12" font-family="monospace" fill="#94a3b8">// ↑ speak の typo!</text>
                        <text x="28" y="208" font-size="12" font-family="monospace" fill="#94a3b8">}</text>
                        <!-- 結果 -->
                        <rect x="10" y="240" width="330" height="56" rx="8" fill="#fef2f2" stroke="#fca5a5" stroke-width="1.5"/>
                        <text x="175" y="262" text-anchor="middle" font-size="12" font-weight="700" fill="#dc2626">コンパイル通ってしまう！</text>
                        <text x="175" y="282" text-anchor="middle" font-size="11" fill="#991b1b">新しいメソッドとして扱われ、親のspeak()がそのまま残る</text>
                        <!-- ===== OK例（右） ===== -->
                        <text x="360" y="22" font-size="13" font-weight="700" fill="#16a34a">@Override あり ― コンパイルエラーで即発見</text>
                        <rect x="360" y="32" width="330" height="200" rx="10" fill="#1e293b"/>
                        <text x="378" y="58" font-size="12" font-family="monospace" fill="#94a3b8">class Animal {</text>
                        <text x="396" y="78" font-size="12" font-family="monospace" fill="#67e8f9">public void </text>
                        <text x="502" y="78" font-size="12" font-family="monospace" font-weight="700" fill="#fbbf24">speak</text>
                        <text x="542" y="78" font-size="12" font-family="monospace" fill="#94a3b8">() { ... }</text>
                        <text x="378" y="98" font-size="12" font-family="monospace" fill="#94a3b8">}</text>
                        <text x="378" y="128" font-size="12" font-family="monospace" fill="#94a3b8">class Cat extends Animal {</text>
                        <text x="396" y="148" font-size="12" font-family="monospace" font-weight="700" fill="#4ade80">@Override</text>
                        <text x="396" y="168" font-size="12" font-family="monospace" fill="#67e8f9">public void </text>
                        <text x="502" y="168" font-size="12" font-family="monospace" font-weight="700" fill="#f87171">spiak</text>
                        <text x="542" y="168" font-size="12" font-family="monospace" fill="#94a3b8">() { ... }</text>
                        <text x="396" y="188" font-size="12" font-family="monospace" fill="#94a3b8">// ↑ 同じ typo</text>
                        <text x="378" y="208" font-size="12" font-family="monospace" fill="#94a3b8">}</text>
                        <!-- 結果 -->
                        <rect x="360" y="240" width="330" height="56" rx="8" fill="#f0fdf4" stroke="#86efac" stroke-width="1.5"/>
                        <text x="525" y="262" text-anchor="middle" font-size="12" font-weight="700" fill="#16a34a">コンパイルエラー！</text>
                        <text x="525" y="282" text-anchor="middle" font-size="11" fill="#166534">「spiakは親クラスのメソッドではありません」と教えてくれる</text>
                        <!-- ===== まとめ ===== -->
                        <rect x="100" y="314" width="500" height="48" rx="10" fill="#fefce8" stroke="#fbbf24" stroke-width="1.5"/>
                        <text x="350" y="336" text-anchor="middle" font-size="12" font-weight="700" fill="#854d0e">@Override を常に付ける = タイプミスを実行前に発見できる安全装置</text>
                        <text x="350" y="354" text-anchor="middle" font-size="11" fill="#854d0e">オーバーライドしたつもりが「新しいメソッド追加」になるバグを防止</text>
                    </svg>
                </div>
                <!-- 構文 -->
                <div class="syntax-box">
                    <div class="syntax-box-header">
                        <span class="syntax-box-icon"><span class="material-icons">menu_book</span></span>
                        <span class="syntax-box-title">構文説明</span>
                    </div>
                    <div class="syntax-box-content">
                        <div class="syntax-item">
                            <h4>@Overrideアノテーション</h4>
                            <div class="syntax-pattern">@Override
public 戻り値型 メソッド名(引数) { }</div>
                            <p>@Overrideアノテーションを付けると、親クラスに同名・同引数のメソッドが存在するかコンパイラがチェックします。存在しない場合はコンパイルエラーになるため、タイプミスを防止できます。</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- オーバーライドの成立条件まとめ -->
            <div style="background: #f8fafc; border: 2px solid #e2e8f0; border-radius: 16px; padding: 24px; margin: 24px 0;">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px;">
                    <span class="material-icons" style="color: #0097A7;">checklist</span>
                    <span style="font-size: 16px; font-weight: 700; color: #1e293b;">オーバーライドの成立条件まとめ</span>
                </div>
                <table class="data-table">
                    <thead>
                        <tr><th>条件</th><th>ルール</th><th>例</th></tr>
                    </thead>
                    <tbody>
                        <tr><td>メソッド名</td><td>親と<strong>同じ</strong></td><td>speak() → speak()</td></tr>
                        <tr><td>引数リスト</td><td>親と<strong>完全に同じ</strong>（型・数・順序）</td><td>(int a, String b) → (int a, String b)</td></tr>
                        <tr><td>戻り値の型</td><td>親と同じ、または<strong>共変戻り値</strong>（サブクラス型）</td><td>Object → String（OK）</td></tr>
                        <tr><td>アクセス修飾子</td><td>親と同じか<strong>より広い</strong></td><td>protected → public（OK）<br>public → private（NG）</td></tr>
                        <tr><td>例外</td><td>親と同じか<strong>より狭い</strong>例外のみ</td><td>Exception → IOException（OK）</td></tr>
                    </tbody>
                </table>
                <div style="margin-top: 12px; padding: 10px 14px; background: #fef3c7; border-radius: 8px; border-left: 4px solid #f59e0b;">
                    <span style="font-size: 13px; color: #92400e;"><strong>引数が異なる場合はオーバーロード</strong>（別メソッドの追加）になり、オーバーライドにはなりません。</span>
                </div>
            </div>

            <!-- ========== 12-2-4 finalメソッドとfinalクラス ========== -->
            <div class="subsection">
                <h3 class="subsection-title">12-2-4 finalメソッドとfinalクラス</h3>
                <!-- 説明 -->
                <div class="content-block">
                    <p><code>final</code>キーワードを使うと、継承やオーバーライドを禁止できます。<strong>finalメソッド</strong>は子クラスでオーバーライドできず、<strong>finalクラス</strong>は他のクラスから継承できません。変更されたくない重要な処理やクラスを保護するために使います。</p>
                </div>
                <!-- プロンプト -->
                <div class="prompt-box">
                    <div class="prompt-box-header">
                        <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                        <span class="prompt-box-title">プロンプト</span>
                        <button class="prompt-copy-btn">コピー</button>
                    </div>
                    <div class="prompt-box-content">
                        <pre><code>## 機能
finalキーワードの使い方を確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter06
- ファイル名: FinalDemo.java

## 実装要件
- finalメソッドを定義（サブクラスでオーバーライド不可）
- finalクラスを定義（他のクラスから継承不可）
- finalによる制限の効果を示す


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする
- 1ファイルで完結するよう、必要なクラスをすべて含める

## 使用するJava構文
- final修飾子（メソッド）
- final修飾子（クラス）
- 継承・オーバーライドの制限</code></pre>
                    </div>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-title">chapter06/FinalDemo.java</span><span class="code-lang">Java</span></div>
                    <pre class="code-content"><code>public class FinalDemo {
    public static void main(String[] args) {
        // finalメソッド：オーバーライド不可
        public final void cannotOverride() { }

        // finalクラス：継承不可
        public final class CannotExtend { }
    }
}</code></pre>
                </div>
                <div class="syntax-box">
                    <div class="syntax-box-header">
                        <span class="syntax-box-icon"><span class="material-icons">menu_book</span></span>
                        <span class="syntax-box-title">構文説明</span>
                    </div>
                    <div class="syntax-box-content">
                        <div class="syntax-item">
                            <h4>final修飾子</h4>
                            <div class="syntax-pattern">public final void メソッド名() { }

public final class クラス名 { }</div>
                            <p>finalを付けたメソッドはオーバーライドできません。finalを付けたクラスは継承できません。変更されたくない重要な処理を保護するために使用します。</p>
                        </div>
                    </div>
                </div>

            <!-- 実際のユースケース -->
            <div class="info-box">
                <div class="info-box-header"><span class="info-box-icon"><span class="material-icons">work</span></span><span class="info-box-title">実際のユースケース</span></div>
                <ul class="bullet-list">
                    <li><strong>toString() のオーバーライド</strong>：エンティティクラスで <code>toString()</code> をオーバーライドし、ログ出力やデバッグ時にオブジェクトの中身をわかりやすく表示します。</li>
                    <li><strong>テンプレートメソッドパターン</strong>：親クラスで処理の流れ（前処理→本処理→後処理）を定義し、子クラスが本処理だけをオーバーライドします。バッチ処理や帳票生成などで活用されます。</li>
                    <li><strong>equals() / hashCode() のオーバーライド</strong>：DTO やエンティティで <code>equals()</code> と <code>hashCode()</code> をオーバーライドし、オブジェクト同士の正しい比較や <code>HashMap</code> でのキー利用を可能にします。</li>
                </ul>
            </div>
            </div>

            <!-- 基礎問題 -->
            <div class="subsection">
                <h3 class="subsection-title">基礎問題</h3>
                <div class="content-block">
                    <p>オーバーライドと super を使って、<strong>図形の説明プログラム</strong>を作ってみましょう。親クラス「Shape」の describe() メソッドを、子クラス「Circle」「Rectangle」でそれぞれ上書きします。</p>
                </div>
                <div class="exercise-list">
                    <div class="exercise-item">
                        <div class="exercise-number">Q</div>
                        <div class="exercise-content">
                            <p>以下の要件を満たすプログラムを、下のプロンプトを使って作成してください。</p>
                            <ul class="bullet-list">
                                <li>「図形」の親クラスに色と説明表示の機能を持たせる</li>
                                <li>「円」は図形の仲間で、describe() を上書きし、親の処理も呼んでから追加情報を表示する</li>
                                <li>「四角形」も図形の仲間で、同様に describe() を上書きする</li>
                                <li>@Override をつけて、上書きしたことを明示する</li>
                            </ul>
                        </div>
                    </div>
                </div>
                <!-- プロンプト -->
                <div class="prompt-box">
                    <div class="prompt-box-header">
                        <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                        <span class="prompt-box-title">基礎問題プロンプト</span>
                        <button class="prompt-copy-btn">コピー</button>
                    </div>
                    <div class="prompt-box-content">
                        <pre><code>## 作りたいもの
図形の情報を表示するプログラム

## 生成先
- ディレクトリ: chapter06
- ファイル名: ShapeDemo.java

## やりたいこと
- 「図形」という共通のグループを作る
  - 色の情報を持つ（子のグループからも使えるようにする）
  - 「○○の図形です」と表示する機能を持つ
- 「円」は「図形」の仲間として作る
  - 半径の情報を追加で持つ
  - 表示機能を書き換えて、まず親の表示を実行してから「→ 半径○○の円です」と追加で表示する
  - @Override をつけて書き換えたことを明示する
- 「四角形」も「図形」の仲間として作る
  - 幅と高さの情報を追加で持つ
  - 表示機能を書き換えて、まず親の表示を実行してから「→ 幅○○ × 高さ○○の四角形です」と追加で表示する
  - @Override をつけて書き換えたことを明示する

## 動かし方
- 円を1つ作って、色を「赤」、半径を5.0にして表示
- 「---」を区切り線として表示
- 四角形を1つ作って、色を「青」、幅を4.0、高さを3.0にして表示
- 全ての結果を画面に表示する
- 1つのファイルにすべてまとめる</code></pre>
                    </div>
                </div>
                <!-- サンプルソースコード -->
                <div class="code-block">
                    <div class="code-header"><span class="code-title">chapter06/ShapeDemo.java（解答例）</span><span class="code-lang">Java</span></div>
                    <pre class="code-content"><code>// 親クラス（図形）
class Shape {
    protected String color;

    public void describe() {
        System.out.println(color + "の図形です");
    }
}

// 子クラス（円）
class Circle extends Shape {
    protected double radius;

    @Override
    public void describe() {
        super.describe();  // 親の処理を呼ぶ
        System.out.println("→ 半径" + radius + "の円です");
    }
}

// 子クラス（四角形）
class Rectangle extends Shape {
    protected double width;
    protected double height;

    @Override
    public void describe() {
        super.describe();  // 親の処理を呼ぶ
        System.out.println("→ 幅" + width + " × 高さ" + height + "の四角形です");
    }
}

public class ShapeDemo {
    public static void main(String[] args) {
        Circle circle = new Circle();
        circle.color = "赤";
        circle.radius = 5.0;
        circle.describe();
        // 出力: 赤の図形です
        //       → 半径5.0の円です

        System.out.println("---");

        Rectangle rect = new Rectangle();
        rect.color = "青";
        rect.width = 4.0;
        rect.height = 3.0;
        rect.describe();
        // 出力: 青の図形です
        //       → 幅4.0 × 高さ3.0の四角形です
    }
}</code></pre>
                </div>
            </div>
        </section>

        <!-- セクション 12-3 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Section 12-3</span>
                <h2 class="section-title">継承関係におけるコンストラクタ</h2>
            </div>

            <!-- 概要 -->
            <div class="intro-text">
                <p>サブクラスのオブジェクトを生成する際、親クラスのコンストラクタも呼び出されます。super()を使って親クラスのコンストラクタを明示的に呼び出すことで、親クラスのフィールドを適切に初期化できます。この仕組みを理解することで、継承階層を正しく設計できます。</p>
            </div>

            <!-- 説明 -->
            <div class="content-block">
                <p><code>new Dog("ポチ", "柴犬")</code>を実行すると、Dogのコンストラクタに入り、最初の行の<code>super(name)</code>で親クラスAnimalのコンストラクタが先に実行されます。親の初期化が完了してから、子クラスの残りの処理が実行されます。</p>
            </div>

            <!-- 図解 -->
            <div class="content-block">
                <div class="figure" style="margin: 20px 0;">
                    <div class="figure-caption">コンストラクタチェーン ― new Dog() すると親→子の順で初期化される</div>
                    <svg viewBox="0 0 700 380" style="max-width: 700px; width: 100%; height: auto;">
                        <!-- ===== コード行 ===== -->
                        <rect x="120" y="10" width="460" height="40" rx="8" fill="#1e293b"/>
                        <text x="140" y="36" font-size="14" font-family="monospace" fill="#38bdf8">new</text>
                        <text x="174" y="36" font-size="14" font-family="monospace" fill="#fbbf24"> Dog</text>
                        <text x="212" y="36" font-size="14" font-family="monospace" fill="#94a3b8">(</text>
                        <text x="222" y="36" font-size="14" font-family="monospace" fill="#a5f3fc">"ポチ"</text>
                        <text x="271" y="36" font-size="14" font-family="monospace" fill="#94a3b8">, </text>
                        <text x="285" y="36" font-size="14" font-family="monospace" fill="#a5f3fc">"柴犬"</text>
                        <text x="333" y="36" font-size="14" font-family="monospace" fill="#94a3b8">);</text>

                        <!-- ===== Step 1: Dog コンストラクタ呼び出し ===== -->
                        <rect x="10" y="70" width="330" height="110" rx="12" fill="#fef3c7" stroke="#f59e0b" stroke-width="2"/>
                        <rect x="10" y="70" width="330" height="34" rx="12" fill="#f59e0b"/>
                        <rect x="10" y="90" width="330" height="14" fill="#f59e0b"/>
                        <text x="28" y="93" font-size="12" font-weight="700" fill="white">Step 1</text>
                        <text x="88" y="93" font-size="12" font-weight="600" fill="white">Dog コンストラクタに入る</text>
                        <rect x="28" y="114" width="294" height="24" rx="6" fill="white" stroke="#fde68a" stroke-width="1"/>
                        <text x="175" y="131" text-anchor="middle" font-size="12" font-family="monospace" fill="#92400e">super(name); ← 最初の行で親を呼ぶ</text>
                        <rect x="28" y="146" width="294" height="24" rx="6" fill="white" stroke="#fde68a" stroke-width="1"/>
                        <text x="175" y="163" text-anchor="middle" font-size="12" font-family="monospace" fill="#92400e">this.breed = breed;</text>

                        <!-- ===== 矢印 Step 1 → Step 2 ===== -->
                        <line x1="175" y1="118" x2="540" y2="118" stroke="#f59e0b" stroke-width="2" stroke-dasharray="6,4"/>
                        <line x1="540" y1="118" x2="540" y2="230" stroke="#f59e0b" stroke-width="2" stroke-dasharray="6,4" marker-end="url(#arrowConst)"/>
                        <text x="400" y="110" font-size="11" font-weight="600" fill="#f59e0b">super() で親に飛ぶ</text>

                        <!-- ===== Step 2: Animal コンストラクタ実行 ===== -->
                        <rect x="360" y="230" width="330" height="90" rx="12" fill="#e0f2fe" stroke="#0ea5e9" stroke-width="2"/>
                        <rect x="360" y="230" width="330" height="34" rx="12" fill="#0ea5e9"/>
                        <rect x="360" y="250" width="330" height="14" fill="#0ea5e9"/>
                        <text x="378" y="253" font-size="12" font-weight="700" fill="white">Step 2</text>
                        <text x="440" y="253" font-size="12" font-weight="600" fill="white">Animal コンストラクタを実行</text>
                        <rect x="378" y="276" width="294" height="24" rx="6" fill="white" stroke="#bae6fd" stroke-width="1"/>
                        <text x="525" y="293" text-anchor="middle" font-size="12" font-family="monospace" fill="#0284c7">this.name = name; → "ポチ"</text>

                        <!-- ===== 矢印 Step 2 → Step 3 ===== -->
                        <line x1="360" y1="290" x2="175" y2="290" stroke="#0ea5e9" stroke-width="2" stroke-dasharray="6,4"/>
                        <line x1="175" y1="290" x2="175" y2="200" stroke="#0ea5e9" stroke-width="2" stroke-dasharray="6,4" marker-end="url(#arrowConst2)"/>
                        <text x="260" y="282" font-size="11" font-weight="600" fill="#0ea5e9">親の処理が終わり戻る</text>

                        <!-- ===== Step 3 ===== -->
                        <rect x="10" y="200" width="330" height="34" rx="8" fill="#fefce8" stroke="#fbbf24" stroke-width="1.5"/>
                        <text x="28" y="222" font-size="12" font-weight="700" fill="#854d0e">Step 3</text>
                        <text x="88" y="222" font-size="12" fill="#854d0e">Dog の残りを実行 → breed = "柴犬"</text>

                        <!-- ===== 結果 ===== -->
                        <rect x="10" y="340" width="680" height="34" rx="8" fill="#f0fdf4" stroke="#86efac" stroke-width="1.5"/>
                        <text x="350" y="362" text-anchor="middle" font-size="12" font-weight="600" fill="#166534">結果: name="ポチ"（Animalで設定）, breed="柴犬"（Dogで設定）→ すべて正しく初期化！</text>

                        <defs>
                            <marker id="arrowConst" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                                <path d="M 0 0 L 10 5 L 0 10 z" fill="#f59e0b"/>
                            </marker>
                            <marker id="arrowConst2" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                                <path d="M 0 0 L 10 5 L 0 10 z" fill="#0ea5e9"/>
                            </marker>
                        </defs>
                    </svg>
                </div>
            </div>

            <div class="prompt-box">
                <div class="prompt-box-header">
                    <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                    <span class="prompt-box-title">プロンプト</span>
                    <button class="prompt-copy-btn">コピー</button>
                </div>
                <div class="prompt-box-content">
                    <pre><code>## 機能
継承関係でのコンストラクタの呼び出しを確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter06
- ファイル名: SuperConstructorDemo.java

## 実装要件
- 親クラス(Animal)にコンストラクタを定義（nameを初期化）
- 子クラス(Dog)のコンストラクタでsuper()を使って親クラスのコンストラクタを呼び出す
- 子クラス独自のフィールド(breed)も初期化する
- super()は必ずコンストラクタの最初の行に記述


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする
- 1ファイルで完結するよう、必要なクラスをすべて含める

## 使用するJava構文
- super()によるコンストラクタ呼び出し
- 継承関係でのフィールド初期化
- コンストラクタチェーン</code></pre>
                </div>
            </div>
            <div class="code-block">
                <div class="code-header"><span class="code-title">chapter06/SuperConstructorDemo.java</span><span class="code-lang">Java</span></div>
                <pre class="code-content"><code>class Animal {
    protected String name;

    public Animal(String name) {
        this.name = name;
    }
}

class Dog extends Animal {
    private String breed;

    public Dog(String name, String breed) {
        super(name);  // 親クラスのコンストラクタを呼び出し（必須）
        this.breed = breed;
    }
}

public class SuperConstructorDemo {
    public static void main(String[] args) {
        Dog dog = new Dog("ポチ", "柴犬");
        System.out.println(dog.name);  // ポチ
    }
}</code></pre>
            </div>
            <div class="syntax-box">
                <div class="syntax-box-header">
                    <span class="syntax-box-icon"><span class="material-icons">menu_book</span></span>
                    <span class="syntax-box-title">構文説明</span>
                </div>
                <div class="syntax-box-content">
                    <div class="syntax-item">
                        <h4>super（親コンストラクタ呼び出し）</h4>
                        <div class="syntax-pattern">super(引数);</div>
                        <p>サブクラスのコンストラクタから親クラスのコンストラクタを呼び出します。必ずコンストラクタの最初の行に記述する必要があります。親クラスにデフォルトコンストラクタがない場合は必須です。</p>
                    </div>
                </div>
            </div>
            <div class="warning-box">
                <div class="warning-box-header"><span class="warning-box-icon"><span class="material-icons">warning</span></span><span class="warning-box-title">super()の位置</span></div>
                <p><code>super()</code>はコンストラクタの最初の行に記述する必要があります。</p>
            </div>

            <!-- 実際のユースケース -->
            <div class="info-box">
                <div class="info-box-header"><span class="info-box-icon"><span class="material-icons">work</span></span><span class="info-box-title">実際のユースケース</span></div>
                <ul class="bullet-list">
                    <li><strong>JPA エンティティの初期化</strong>：親クラス（BaseEntity）のコンストラクタで <code>createdAt = LocalDateTime.now()</code> を設定し、子クラスのコンストラクタから <code>super()</code> で呼び出すことで、全エンティティの作成日時を自動セットします。</li>
                    <li><strong>カスタム例外の定義</strong>：<code>super(message)</code> で親の <code>RuntimeException</code> にエラーメッセージを渡し、業務固有の例外クラスを簡潔に定義します。</li>
                    <li><strong>GUI コンポーネントの初期化</strong>：Swing や JavaFX で親クラス（JPanel など）のコンストラクタを呼んでから、子クラスで独自の UI 部品を追加する設計が一般的です。</li>
                </ul>
            </div>

            <!-- 基礎問題 -->
            <div class="subsection">
                <h3 class="subsection-title">基礎問題</h3>
                <div class="content-block">
                    <p>super() を使ったコンストラクタチェーンを実践してみましょう。<strong>商品と本の管理プログラム</strong>で、親の初期化 → 子の初期化という流れを確認します。</p>
                </div>
                <div class="exercise-list">
                    <div class="exercise-item">
                        <div class="exercise-number">Q</div>
                        <div class="exercise-content">
                            <p>以下の要件を満たすプログラムを、下のプロンプトを使って作成してください。</p>
                            <ul class="bullet-list">
                                <li>「商品」の親クラスに商品名と価格を、作成時に設定する仕組みを持たせる</li>
                                <li>「本」は商品の仲間で、作成時に商品名・価格・著者をまとめて受け取る</li>
                                <li>「本」は作成時にまず親（商品）の初期化を呼んでから、著者を設定する</li>
                                <li>初期化が親 → 子の順で実行されることを画面出力で確認する</li>
                            </ul>
                        </div>
                    </div>
                </div>
                <!-- プロンプト -->
                <div class="prompt-box">
                    <div class="prompt-box-header">
                        <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                        <span class="prompt-box-title">基礎問題プロンプト</span>
                        <button class="prompt-copy-btn">コピー</button>
                    </div>
                    <div class="prompt-box-content">
                        <pre><code>## 作りたいもの
商品と本の情報を管理するプログラム

## 生成先
- ディレクトリ: chapter06
- ファイル名: ProductDemo.java

## やりたいこと
- 「商品」という共通のグループを作る
  - 商品名と価格の情報を、作成時に受け取って設定する
  - 作成時に「Productの初期化: ○○を登録」と画面に表示する
  - 「商品名: ○○ / 価格: ○○円」と表示する機能を持つ
- 「本」は「商品」の仲間として作る
  - 商品名、価格に加えて著者の情報を作成時に受け取る
  - 作成時にまず親（商品）の初期化を呼び出してから、著者を設定する
  - 作成時に「Bookの初期化: 著者 ○○ を設定」と画面に表示する
  - 詳細を表示する機能では、親の情報表示を使ってから「著者: ○○」を追加で表示する

## 動かし方
- 本を1冊作る（商品名「Java入門」、価格2800、著者「山田太郎」）
- 作成時のメッセージが親→子の順で表示されることを確認
- 「---」を区切り線として表示
- 詳細表示を実行して、商品情報と著者情報が表示されることを確認
- 1つのファイルにすべてまとめる</code></pre>
                    </div>
                </div>
                <!-- サンプルソースコード -->
                <div class="code-block">
                    <div class="code-header"><span class="code-title">chapter06/ProductDemo.java（解答例）</span><span class="code-lang">Java</span></div>
                    <pre class="code-content"><code>// 親クラス（商品）
class Product {
    protected String name;
    protected int price;

    public Product(String name, int price) {
        this.name = name;
        this.price = price;
        System.out.println("Productの初期化: " + name + "を登録");
    }

    public void showInfo() {
        System.out.println("商品名: " + name + " / 価格: " + price + "円");
    }
}

// 子クラス（本）― Book is-a Product
class Book extends Product {
    private String author;

    public Book(String name, int price, String author) {
        super(name, price);  // 親の初期化を呼ぶ（必ず最初の行）
        this.author = author;
        System.out.println("Bookの初期化: 著者 " + author + " を設定");
    }

    public void showDetail() {
        showInfo();  // 親のメソッドを使う
        System.out.println("著者: " + author);
    }
}

public class ProductDemo {
    public static void main(String[] args) {
        Book book = new Book("Java入門", 2800, "山田太郎");
        // 出力: Productの初期化: Java入門を登録
        //       Bookの初期化: 著者 山田太郎 を設定

        System.out.println("---");

        book.showDetail();
        // 出力: 商品名: Java入門 / 価格: 2800円
        //       著者: 山田太郎
    }
}</code></pre>
                </div>
            </div>
        </section>

        <!-- セクション 12-4 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Section 12-4</span>
                <h2 class="section-title">Objectクラスとレコードクラス</h2>
            </div>

            <div class="intro-text">
                <p>Objectクラスは全クラスの祖先であり、toString()やequals()などの基本メソッドを提供します。また、Java 16で導入されたレコードクラスは、データを保持するだけのクラスを簡潔に定義できる新機能です。DTOやエンティティの定義が格段に楽になります。</p>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">12-4-1 Objectクラス</h3>
                <div class="content-block">
                    <p>すべてのクラスは<code>java.lang.Object</code>を継承しています。主要メソッド：</p>
                    <ul class="bullet-list">
                        <li><code>toString()</code> - 文字列表現を返す</li>
                        <li><code>equals(Object)</code> - 等価性を比較</li>
                        <li><code>hashCode()</code> - ハッシュコードを返す</li>
                    </ul>
                </div>

                <!-- Object クラス階層図 -->
                <div class="figure" style="margin: 20px 0;">
                    <div class="figure-caption">Objectクラスを頂点とする継承ツリー</div>
                    <svg viewBox="0 0 700 480" style="max-width: 700px; width: 100%; height: auto;">
                        <!-- ===== java.lang.Object ===== -->
                        <rect x="200" y="10" width="300" height="130" rx="14" fill="#1e293b" stroke="#475569" stroke-width="2"/>
                        <text x="350" y="40" text-anchor="middle" font-size="15" font-weight="700" fill="white">java.lang.Object</text>
                        <line x1="220" y1="52" x2="480" y2="52" stroke="#475569" stroke-width="1"/>
                        <rect x="230" y="62" width="240" height="24" rx="6" fill="#334155"/>
                        <text x="350" y="79" text-anchor="middle" font-size="12" font-family="monospace" fill="#67e8f9">toString()</text>
                        <rect x="230" y="92" width="240" height="24" rx="6" fill="#334155"/>
                        <text x="350" y="109" text-anchor="middle" font-size="12" font-family="monospace" fill="#67e8f9">equals() / hashCode()</text>

                        <!-- ===== 矢印: Object → String (左) ===== -->
                        <line x1="350" y1="140" x2="350" y2="170" stroke="#64748b" stroke-width="2"/>
                        <line x1="350" y1="170" x2="160" y2="170" stroke="#64748b" stroke-width="2"/>
                        <line x1="160" y1="170" x2="160" y2="210" stroke="#64748b" stroke-width="2" marker-end="url(#arrowObj)"/>

                        <!-- ===== 矢印: Object → Animal (右) ===== -->
                        <line x1="350" y1="170" x2="540" y2="170" stroke="#64748b" stroke-width="2"/>
                        <line x1="540" y1="170" x2="540" y2="210" stroke="#64748b" stroke-width="2" marker-end="url(#arrowObj)"/>

                        <!-- extends ラベル -->
                        <rect x="300" y="158" width="100" height="24" rx="6" fill="#475569"/>
                        <text x="350" y="175" text-anchor="middle" font-size="11" font-weight="700" fill="white">extends</text>

                        <!-- ===== String (左) ===== -->
                        <rect x="40" y="210" width="240" height="80" rx="14" fill="#dcfce7" stroke="#22c55e" stroke-width="2"/>
                        <rect x="40" y="210" width="240" height="34" rx="14" fill="#22c55e"/>
                        <rect x="40" y="230" width="240" height="14" fill="#22c55e"/>
                        <text x="160" y="232" text-anchor="middle" font-size="14" font-weight="700" fill="white">String</text>
                        <text x="160" y="264" text-anchor="middle" font-size="11" fill="#166534">final class, extends Object</text>
                        <text x="160" y="282" text-anchor="middle" font-size="10" fill="#64748b">toString(), equals() をオーバーライド済み</text>

                        <!-- ===== Animal (右) ===== -->
                        <rect x="420" y="210" width="240" height="80" rx="14" fill="#dbeafe" stroke="#3b82f6" stroke-width="2"/>
                        <rect x="420" y="210" width="240" height="34" rx="14" fill="#3b82f6"/>
                        <rect x="420" y="230" width="240" height="14" fill="#3b82f6"/>
                        <text x="540" y="232" text-anchor="middle" font-size="14" font-weight="700" fill="white">Animal</text>
                        <text x="540" y="264" text-anchor="middle" font-size="11" fill="#1e40af">自作クラスも暗黙的に</text>
                        <text x="540" y="280" text-anchor="middle" font-size="11" fill="#1e40af">Objectを継承</text>

                        <!-- ===== 矢印: Animal → Dog ===== -->
                        <line x1="540" y1="290" x2="540" y2="340" stroke="#3b82f6" stroke-width="2" marker-end="url(#arrowObj2)"/>
                        <text x="560" y="320" font-size="11" font-weight="600" fill="#3b82f6">extends</text>

                        <!-- ===== Dog ===== -->
                        <rect x="420" y="340" width="240" height="70" rx="14" fill="#fef3c7" stroke="#f59e0b" stroke-width="2"/>
                        <rect x="420" y="340" width="240" height="34" rx="14" fill="#f59e0b"/>
                        <rect x="420" y="360" width="240" height="14" fill="#f59e0b"/>
                        <text x="540" y="362" text-anchor="middle" font-size="14" font-weight="700" fill="white">Dog</text>
                        <text x="540" y="394" text-anchor="middle" font-size="11" fill="#92400e">extends Animal</text>

                        <!-- ===== まとめ注釈 ===== -->
                        <rect x="100" y="434" width="500" height="36" rx="10" fill="#f3e8ff" stroke="#a855f7" stroke-width="1.5"/>
                        <text x="350" y="457" text-anchor="middle" font-size="12" font-weight="600" fill="#7e22ce">すべてのクラスはObjectを頂点とする継承ツリーに属する</text>

                        <defs>
                            <marker id="arrowObj" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                                <path d="M 0 0 L 10 5 L 0 10 z" fill="#64748b"/>
                            </marker>
                            <marker id="arrowObj2" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                                <path d="M 0 0 L 10 5 L 0 10 z" fill="#3b82f6"/>
                            </marker>
                        </defs>
                    </svg>
                </div>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">12-4-2 レコードクラス（Java 16以降）</h3>
                <!-- 説明 -->
                <div class="content-block">
                    <p>レコードクラスは、データを保持するだけのクラスを1行で簡潔に定義できるJava 16以降の機能です。フィールド、コンストラクタ、アクセサメソッド、<code>equals()</code>/<code>hashCode()</code>/<code>toString()</code>がすべて自動生成されます。</p>
                </div>
                <!-- プロンプト -->
                <div class="prompt-box">
                    <div class="prompt-box-header">
                        <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                        <span class="prompt-box-title">プロンプト</span>
                        <button class="prompt-copy-btn">コピー</button>
                    </div>
                    <div class="prompt-box-content">
                        <pre><code>## 機能
レコードクラスを使ったデータ保持の動作を確認するサンプルプロジェクト

## 生成先
- ディレクトリ: chapter06
- ファイル名: RecordDemo.java

## 実装要件
- record キーワードでPersonレコードを定義
- nameとageをコンポーネントとして持つ
- レコードのインスタンス化と値の取得を示す
- toString()の自動生成を確認


- mainメソッドを含め、System.out.printlnで各処理の実行結果を出力して動作確認できるようにする
- 1ファイルで完結するよう、必要なクラスをすべて含める

## 使用するJava構文
- record キーワード（Java 16以降）
- イミュータブルなデータクラス
- 自動生成されるアクセサメソッド</code></pre>
                    </div>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-title">chapter06/RecordDemo.java</span><span class="code-lang">Java</span></div>
                    <pre class="code-content"><code>public class RecordDemo {
    public static void main(String[] args) {
        // データ保持用クラスを簡潔に定義
        public record Person(String name, int age) { }

        // 使用例
        Person p = new Person("Alice", 25);
        System.out.println(p.name());  // Alice
        System.out.println(p);  // Person[name=Alice, age=25]
    }
}</code></pre>
                </div>
                <!-- 解説 -->
                <div class="info-box">
                    <div class="info-box-header"><span class="info-box-icon"><span class="material-icons">lightbulb</span></span><span class="info-box-title">レコードの特徴</span></div>
                    <p>レコードはイミュータブル（不変）で、一度生成したら値を変更できません。equals/hashCode/toStringが自動生成されるため、DTOやデータ受け渡し用クラスの定義が格段に簡潔になります。</p>
                </div>

                <!-- 通常クラス vs レコード 比較図 -->
                <div style="background: #f8fafc; border: 2px solid #e2e8f0; border-radius: 16px; padding: 24px; margin: 24px 0;">
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px;">
                        <span class="material-icons" style="color: #0097A7;">compare_arrows</span>
                        <span style="font-size: 16px; font-weight: 700; color: #1e293b;">通常のクラス vs レコード 比較</span>
                    </div>
                    <div style="display: flex; gap: 16px; flex-wrap: wrap;">
                        <!-- 左: 通常のクラス -->
                        <div style="flex: 1; min-width: 280px; background: #fff; border: 2px solid #fca5a5; border-radius: 12px; padding: 16px;">
                            <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 12px;">
                                <span class="material-icons" style="color: #ef4444; font-size: 20px;">code</span>
                                <span style="font-size: 14px; font-weight: 700; color: #dc2626;">通常のクラス（約20行）</span>
                            </div>
                            <div style="background: #1e293b; border-radius: 8px; padding: 14px; font-family: 'JetBrains Mono', monospace; font-size: 12px; line-height: 1.7; color: #94a3b8; overflow-x: auto;">
                                <span style="color: #67e8f9;">class</span> <span style="color: #fbbf24;">Person</span> {<br>
                                &nbsp;&nbsp;<span style="color: #94a3b8;">// フィールド</span><br>
                                &nbsp;&nbsp;<span style="color: #67e8f9;">private</span> String name;<br>
                                &nbsp;&nbsp;<span style="color: #67e8f9;">private int</span> age;<br>
                                <br>
                                &nbsp;&nbsp;<span style="color: #94a3b8;">// コンストラクタ</span><br>
                                &nbsp;&nbsp;<span style="color: #67e8f9;">public</span> <span style="color: #fbbf24;">Person</span>(String name, <span style="color: #67e8f9;">int</span> age) {<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #67e8f9;">this</span>.name = name;<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #67e8f9;">this</span>.age = age;<br>
                                &nbsp;&nbsp;}<br>
                                <br>
                                &nbsp;&nbsp;<span style="color: #94a3b8;">// getter</span><br>
                                &nbsp;&nbsp;String <span style="color: #86efac;">getName</span>() { <span style="color: #67e8f9;">return</span> name; }<br>
                                &nbsp;&nbsp;<span style="color: #67e8f9;">int</span> <span style="color: #86efac;">getAge</span>() { <span style="color: #67e8f9;">return</span> age; }<br>
                                <br>
                                &nbsp;&nbsp;<span style="color: #94a3b8;">// toString, equals, hashCode...</span><br>
                                &nbsp;&nbsp;<span style="color: #94a3b8;">// さらに10行以上必要</span><br>
                                }
                            </div>
                        </div>
                        <!-- 右: レコード -->
                        <div style="flex: 1; min-width: 280px; background: #fff; border: 2px solid #22c55e; border-radius: 12px; padding: 16px;">
                            <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 12px;">
                                <span class="material-icons" style="color: #22c55e; font-size: 20px;">bolt</span>
                                <span style="font-size: 14px; font-weight: 700; color: #16a34a;">レコード（1行）</span>
                            </div>
                            <div style="background: #1e293b; border-radius: 8px; padding: 14px; font-family: 'JetBrains Mono', monospace; font-size: 12px; line-height: 1.7; color: #94a3b8; overflow-x: auto;">
                                <span style="color: #67e8f9;">record</span> <span style="color: #fbbf24;">Person</span>(<span style="color: #86efac;">String</span> name, <span style="color: #67e8f9;">int</span> age) {}
                            </div>
                            <div style="margin-top: 14px;">
                                <div style="font-size: 13px; font-weight: 600; color: #166534; margin-bottom: 8px;">自動生成されるもの:</div>
                                <div style="display: flex; flex-direction: column; gap: 4px;">
                                    <div style="display: flex; align-items: center; gap: 6px; font-size: 12px; color: #334155;">
                                        <span class="material-icons" style="color: #22c55e; font-size: 16px;">check_circle</span>
                                        コンストラクタ
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 6px; font-size: 12px; color: #334155;">
                                        <span class="material-icons" style="color: #22c55e; font-size: 16px;">check_circle</span>
                                        アクセサ: name() / age()
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 6px; font-size: 12px; color: #334155;">
                                        <span class="material-icons" style="color: #22c55e; font-size: 16px;">check_circle</span>
                                        toString()
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 6px; font-size: 12px; color: #334155;">
                                        <span class="material-icons" style="color: #22c55e; font-size: 16px;">check_circle</span>
                                        equals() / hashCode()
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div style="margin-top: 12px; padding: 10px 14px; background: #fef3c7; border-radius: 8px; border-left: 4px solid #f59e0b;">
                        <span style="font-size: 13px; color: #92400e;"><strong>レコードは不変（immutable）</strong> ― setterは存在せず、値は変更不可</span>
                    </div>
                </div>
            </div>

            <!-- 実際のユースケース -->
            <div class="info-box">
                <div class="info-box-header"><span class="info-box-icon"><span class="material-icons">work</span></span><span class="info-box-title">実際のユースケース</span></div>
                <ul class="bullet-list">
                    <li><strong>toString() でログ出力</strong>：<code>Object</code> の <code>toString()</code> をオーバーライドすれば、<code>System.out.println(user)</code> だけでオブジェクトの中身を確認でき、デバッグやログ出力が格段に楽になります。</li>
                    <li><strong>API のリクエスト/レスポンス DTO</strong>：レコードクラスで <code>record UserResponse(Long id, String name, String email) {}</code> と定義すれば、Spring Boot の REST API で使う DTO を1行で作成できます。</li>
                    <li><strong>設定値の受け渡し</strong>：データベース接続情報やメール設定など、変更されたくない設定値をレコードクラスに格納すると、イミュータブルなため安全に受け渡しできます。</li>
                </ul>
            </div>

            <!-- 基礎問題 -->
            <div class="subsection">
                <h3 class="subsection-title">基礎問題</h3>
                <div class="content-block">
                    <p>toString() のオーバーライドとレコードクラスを比較してみましょう。<strong>学生情報を管理するプログラム</strong>を2つの方法で作成し、違いを確認します。</p>
                </div>
                <div class="exercise-list">
                    <div class="exercise-item">
                        <div class="exercise-number">Q</div>
                        <div class="exercise-content">
                            <p>以下の要件を満たすプログラムを、下のプロンプトを使って作成してください。</p>
                            <ul class="bullet-list">
                                <li>通常のクラスで「学生」を作り、画面表示の形式を自分で書き換える（toString）</li>
                                <li>レコードという簡単な書き方でも同じ「学生」を作る</li>
                                <li>両方を画面に表示して、出力の違いを確認する</li>
                                <li>レコードから名前だけ、年齢だけを取り出して表示する</li>
                            </ul>
                        </div>
                    </div>
                </div>
                <!-- プロンプト -->
                <div class="prompt-box">
                    <div class="prompt-box-header">
                        <span class="prompt-box-icon"><span class="material-icons">chat</span></span>
                        <span class="prompt-box-title">基礎問題プロンプト</span>
                        <button class="prompt-copy-btn">コピー</button>
                    </div>
                    <div class="prompt-box-content">
                        <pre><code>## 作りたいもの
学生情報を管理する2つの方法を比較するプログラム

## 生成先
- ディレクトリ: chapter06
- ファイル名: StudentDemo.java

## やりたいこと
- まず「学生」を通常の方法で作る
  - 名前と年齢の情報を持つ
  - 作成時に名前と年齢を受け取って設定する
  - 画面に表示するときに「Student{name=○○, age=○○}」の形式で出るようにする（toStringを書き換える）
- 次に同じ「学生」をレコードという簡単な書き方で作る
  - 名前と年齢の情報を持つ（1行で定義できる）
  - 画面表示の形式は自動で「StudentRecord[name=○○, age=○○]」になる

## 動かし方
- 通常のクラスで学生を1人作る（名前「田中」、年齢20）→ そのまま画面に表示
- レコードで学生を1人作る（名前「田中」、年齢20）→ そのまま画面に表示
- レコードから名前だけ、年齢だけを取り出して表示
- 1つのファイルにすべてまとめる</code></pre>
                    </div>
                </div>
                <!-- サンプルソースコード -->
                <div class="code-block">
                    <div class="code-header"><span class="code-title">chapter06/StudentDemo.java（解答例）</span><span class="code-lang">Java</span></div>
                    <pre class="code-content"><code>// 通常のクラス（toStringを自分で書き換える）
class Student {
    private String name;
    private int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{name=" + name + ", age=" + age + "}";
    }
}

// レコードクラス（toStringは自動で作られる）
record StudentRecord(String name, int age) {}

public class StudentDemo {
    public static void main(String[] args) {
        // 通常のクラス
        Student s1 = new Student("田中", 20);
        System.out.println(s1);  // Student{name=田中, age=20}

        // レコードクラス
        StudentRecord s2 = new StudentRecord("田中", 20);
        System.out.println(s2);           // StudentRecord[name=田中, age=20]
        System.out.println(s2.name());    // 田中
        System.out.println(s2.age());     // 20
    }
}</code></pre>
                </div>
            </div>
        </section>

        <!-- 練習問題・解答 -->
        <section class="section">
            <div class="section-header"><span class="section-number">Exercise</span><h2 class="section-title">12章 練習問題</h2></div>
            <div class="exercise-list">
                <div class="exercise-item">
                    <div class="exercise-number">Q1</div>
                    <div class="exercise-content">
                        <p>Javaの継承について正しい説明はどれですか？</p>
                        <ol type="A"><li>1つのクラスは複数のクラスを同時に継承できる</li><li>サブクラスは親クラスのprivateフィールドに直接アクセスできる</li><li>extendsキーワードで親クラスを継承する</li><li>継承したメソッドは変更できない</li></ol>
                    </div>
                </div>
                <div class="exercise-item">
                    <div class="exercise-number">Q2</div>
                    <div class="exercise-content">
                        <p>次のコードの出力結果はどれですか？</p>
                        <div class="code-block" style="margin: 12px 0;">
                            <div class="code-header"><span class="code-title">Q2コード</span><span class="code-lang">Java</span></div>
                            <pre class="code-content"><code>class Parent {
    public Parent() {
        System.out.print("P");
    }
}
class Child extends Parent {
    public Child() {
        super();
        System.out.print("C");
    }
}
// 実行: new Child();</code></pre>
                        </div>
                        <ol type="A"><li>C</li><li>PC</li><li>CP</li><li>コンパイルエラー</li></ol>
                    </div>
                </div>
                <div class="exercise-item">
                    <div class="exercise-number">Q3</div>
                    <div class="exercise-content">
                        <p>@Overrideアノテーションについて正しいものはどれですか？</p>
                        <ol type="A"><li>@Overrideを付けないとオーバーライドできない</li><li>@Overrideを付けるとメソッド名のタイプミスをコンパイル時に検出できる</li><li>@Overrideはstaticメソッドにも使用できる</li><li>@Overrideを付けると実行速度が向上する</li></ol>
                    </div>
                </div>
            </div>
        </section>

        <section class="section">
            <div class="section-header"><span class="section-number">Answer</span><h2 class="section-title">12章 解説・解答</h2></div>
            <div class="answer-list">
                <div class="answer-item">
                    <div class="answer-header">Q1の解答: C</div>
                    <div class="answer-content"><p>Javaではextendsキーワードで親クラスを継承します。Javaは単一継承のみ対応（Aは誤り）、privateフィールドにはサブクラスからも直接アクセスできません（Bは誤り）、オーバーライドでメソッドを変更できます（Dは誤り）。</p></div>
                </div>
                <div class="answer-item">
                    <div class="answer-header">Q2の解答: B</div>
                    <div class="answer-content"><p>子クラスのコンストラクタでsuper()が呼ばれ、まず親クラスのコンストラクタが実行されて"P"が出力される。その後、子クラスの残りの処理で"C"が出力される。コンストラクタチェーンは常に親→子の順で実行される。</p></div>
                </div>
                <div class="answer-item">
                    <div class="answer-header">Q3の解答: B</div>
                    <div class="answer-content"><p>@Overrideはコンパイラへのヒントであり、親クラスに同名・同引数のメソッドが存在するかチェックする。存在しない場合（タイプミスなど）はコンパイルエラーになるため、バグを未然に防げる。付けなくてもオーバーライド自体は動作する（Aは誤り）。staticメソッドはオーバーライドできない（Cは誤り）。実行速度には影響しない（Dは誤り）。</p></div>
                </div>
            </div>
        </section>
    </div>

    <footer class="footer"><p>Java Silver 試験対策 教科書</p></footer>

    <div class="page-nav">
        <a href="11java-static.html" class="page-nav-btn prev"><span>&#8592;</span><div><div class="page-nav-label">前の章</div><div class="page-nav-title">第11章</div></div></a>
        <a href="13java-abstract-interface.html" class="page-nav-btn next"><div><div class="page-nav-label">次の章</div><div class="page-nav-title">第13章</div></div><span>&#8594;</span></a>
    </div>

    <script>
        function toggleMenu() {
            const toggle = document.querySelector('.nav-toggle');
            const menu = document.querySelector('.nav-menu');
            toggle.classList.toggle('active');
            menu.classList.toggle('active');
        }
        document.addEventListener('click', function(e) {
            const nav = document.querySelector('.global-nav');
            const toggle = document.querySelector('.nav-toggle');
            const menu = document.querySelector('.nav-menu');
            if (!nav.contains(e.target) && menu.classList.contains('active')) {
                toggle.classList.remove('active');
                menu.classList.remove('active');
            }
        });
    </script>
    <script src="../../shared/demo.js"></script>
</body>
</html>
