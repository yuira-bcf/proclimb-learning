<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第7章 実践：Webアプリのコンテナ化 - Docker構築入門</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700;900&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../shared/common.css">
    <style>
      :root {
        --primary: #2496ED;
        --primary-dark: #1976D2;
        --primary-light: #E3F2FD;
        --primary-lighter: #BBDEFB;
      }
      body { padding-top: 48px; }
      .nav-category-links { display: none; }
      /* 図解用スタイル */
      .visual-diagram {
        margin: 28px 0; padding: 28px 20px;
        background: linear-gradient(135deg, #f0f7fe 0%, #e3f2fd 100%);
        border-radius: 16px; border: 1px solid #bbdefb;
      }
      .visual-diagram-title {
        text-align: center; font-size: 0.82rem; font-weight: 700;
        color: #2496ED; margin-bottom: 20px; letter-spacing: 0.05em;
      }
      .vd-flow {
        display: flex; align-items: center; justify-content: center;
        gap: 10px; flex-wrap: wrap;
      }
      .vd-box {
        background: white; border: 2px solid #2496ED; border-radius: 14px;
        padding: 16px 14px; text-align: center; min-width: 110px;
        box-shadow: 0 2px 8px rgba(36,150,237,0.08);
      }
      .vd-box.accent { background: #2496ED; color: white; }
      .vd-box .vd-icon { font-size: 1.6rem; display: block; margin-bottom: 4px; }
      .vd-box .vd-label { font-size: 0.78rem; font-weight: 700; display: block; }
      .vd-box .vd-sub { font-size: 0.68rem; opacity: 0.7; display: block; margin-top: 2px; }
      .vd-arrow { color: #2496ED; font-size: 1.3rem; font-weight: 700; }
      .vd-grid {
        display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 12px;
      }
      .vd-card {
        background: white; border-radius: 12px; padding: 16px; text-align: center;
        border: 2px solid #e3f2fd; box-shadow: 0 1px 4px rgba(0,0,0,0.04);
      }
      .vd-card .vd-icon { font-size: 1.8rem; display: block; margin-bottom: 6px; }
      .vd-card .vd-label { font-size: 0.78rem; font-weight: 700; display: block; color: #2496ED; }
      .vd-card .vd-sub { font-size: 0.68rem; color: #666; display: block; margin-top: 4px; }
      .vd-card.green { border-color: #a5d6a7; background: #f1f8e9; }
      .vd-card.red { border-color: #ef9a9a; background: #fce4ec; }
      .vd-card.blue { border-color: #90caf9; background: #e3f2fd; }
      .vd-card.amber { border-color: #ffe082; background: #fff8e1; }
      .vd-card.purple { border-color: #ce93d8; background: #f3e5f5; }
      .vd-bar {
        display: flex; border-radius: 12px; overflow: hidden; margin: 16px 0;
      }
      .vd-bar-seg {
        flex: 1; padding: 14px 8px; text-align: center; font-size: 0.72rem; font-weight: 600; color: white;
      }
      @media (max-width: 560px) {
        .vd-flow { flex-direction: column; }
        .vd-arrow { transform: rotate(90deg); }
        .vd-grid { grid-template-columns: repeat(2, 1fr); }
      }
    </style>
</head>
<body>
    <nav class="global-nav"></nav>
    <script src="../shared/js/nav-docker.js"></script>

    <div class="container">
        <header class="chapter-header">
            <div class="chapter-badge"><span class="material-icons">menu_book</span> Chapter</div>
            <div class="chapter-number">7</div>
            <h1 class="chapter-title">実践：Webアプリのコンテナ化</h1>
        </header>

        <nav class="toc">
            <h2 class="toc-title"><span class="material-icons">list_alt</span> この章の内容</h2>
            <ul class="toc-list">
                <li class="toc-item"><span class="toc-number">7-1</span><span>コンテナ化の設計</span></li>
                <li class="toc-item"><span class="toc-number">7-2</span><span>Node.jsアプリのコンテナ化</span></li>
                <li class="toc-item"><span class="toc-number">7-3</span><span>Nginxリバースプロキシの構築</span></li>
                <li class="toc-item"><span class="toc-number">7-4</span><span>Docker Composeで統合管理</span></li>
                <li class="toc-item"><span class="toc-number">7-5</span><span>本番向けイメージの最適化</span></li>
            </ul>
        </nav>

        <!-- セクション 7-1 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Section 7-1</span>
                <h2 class="section-title">コンテナ化の設計</h2>
            </div>

            <div class="intro-text">
                <p>Webアプリケーションをコンテナ化する際は、各コンポーネントを個別のコンテナに分離する「マイクロサービス的なアプローチ」が基本です。この章では、フロントエンド（Nginx）、バックエンド（Node.js）、データベース（MySQL）の3層構成を実践します。</p>
            </div>

            <!-- 図解: Webアプリアーキテクチャ -->
            <div class="visual-diagram">
                <div class="visual-diagram-title">Webアプリケーションの3層コンテナ構成</div>
                <div class="vd-flow">
                    <div class="vd-box">
                        <span class="vd-icon">&#128187;</span>
                        <span class="vd-label">Client</span>
                        <span class="vd-sub">ブラウザ</span>
                    </div>
                    <span class="vd-arrow">&#8594;</span>
                    <div class="vd-box accent">
                        <span class="vd-icon">&#9881;</span>
                        <span class="vd-label">Nginx</span>
                        <span class="vd-sub">リバースプロキシ</span>
                        <span class="vd-sub">:80</span>
                    </div>
                    <span class="vd-arrow">&#8594;</span>
                    <div class="vd-box" style="border-color:#43a047;">
                        <span class="vd-icon">&#9889;</span>
                        <span class="vd-label" style="color:#43a047;">Node.js</span>
                        <span class="vd-sub">APIサーバー</span>
                        <span class="vd-sub">:3000</span>
                    </div>
                    <span class="vd-arrow">&#8594;</span>
                    <div class="vd-box" style="border-color:#e65100;">
                        <span class="vd-icon">&#128451;</span>
                        <span class="vd-label" style="color:#e65100;">MySQL</span>
                        <span class="vd-sub">データベース</span>
                        <span class="vd-sub">:3306</span>
                    </div>
                </div>
                <p style="text-align:center;font-size:0.7rem;color:#666;margin-top:14px;">各コンポーネントを独立したコンテナとして管理し、ネットワークで接続する</p>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">1.1 コンテナ分離の原則</h3>
                <div class="content-block">
                    <p>「1コンテナ = 1プロセス」が基本原則です。この原則に従うことで以下のメリットが得られます。</p>
                    <ul>
                        <li><strong>独立したスケーリング</strong>: 負荷の高いコンポーネントだけスケールアウト</li>
                        <li><strong>独立したデプロイ</strong>: バックエンドだけを更新可能</li>
                        <li><strong>障害の局所化</strong>: 1つのコンテナが落ちても他は影響を受けにくい</li>
                        <li><strong>技術の自由度</strong>: コンテナごとに異なる言語・フレームワークが使える</li>
                    </ul>
                </div>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">1.2 プロジェクト構成</h3>
                <div class="content-block">
                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">プロジェクトのディレクトリ構成</span>
                            <span class="code-lang">Directory</span>
                        </div>
                        <pre class="code-content"><code>my-webapp/
├── docker-compose.yml
├── backend/
│   ├── Dockerfile
│   ├── package.json
│   ├── server.js
│   └── .dockerignore
├── nginx/
│   ├── Dockerfile
│   └── default.conf
└── db/
    └── init.sql</code></pre>
                    </div>
                </div>
            </div>
        </section>

        <!-- セクション 7-2 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Section 7-2</span>
                <h2 class="section-title">Node.jsアプリのコンテナ化</h2>
            </div>

            <div class="intro-text">
                <p>Node.js（Express）で作成したAPIサーバーをDockerコンテナとして動作させます。効率的なDockerfileの書き方と.dockerignoreの設定を学びます。</p>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">2.1 Node.jsアプリケーション</h3>
                <div class="content-block">
                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">backend/package.json</span>
                            <span class="code-lang">JSON</span>
                        </div>
                        <pre class="code-content"><code>{
  "name": "my-api",
  "version": "1.0.0",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "mysql2": "^3.6.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  }
}</code></pre>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">backend/server.js</span>
                            <span class="code-lang">JavaScript</span>
                        </div>
                        <pre class="code-content"><code>const express = require('express');
const mysql = require('mysql2/promise');

const app = express();
app.use(express.json());

// DB接続設定（環境変数から取得）
const pool = mysql.createPool({
  host: process.env.DB_HOST || 'localhost',
  user: process.env.DB_USER || 'root',
  password: process.env.DB_PASSWORD || 'secret',
  database: process.env.DB_NAME || 'myapp'
});

app.get('/api/health', (req, res) =&gt; {
  res.json({ status: 'ok', timestamp: new Date() });
});

app.get('/api/users', async (req, res) =&gt; {
  const [rows] = await pool.query('SELECT * FROM users');
  res.json(rows);
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () =&gt; {
  console.log(`Server running on port ${PORT}`);
});</code></pre>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">2.2 Dockerfileの作成</h3>
                <div class="content-block">
                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">backend/Dockerfile</span>
                            <span class="code-lang">Dockerfile</span>
                        </div>
                        <pre class="code-content"><code># ベースイメージ（Alpine版で軽量化）
FROM node:20-alpine

# 作業ディレクトリを設定
WORKDIR /app

# 依存関係ファイルを先にコピー（キャッシュ活用）
COPY package*.json ./

# 本番依存のみインストール
RUN npm ci --only=production

# アプリケーションコードをコピー
COPY . .

# ポートを公開
EXPOSE 3000

# 非rootユーザーで実行
USER node

# アプリケーション起動
CMD ["node", "server.js"]</code></pre>
                    </div>

                    <div class="info-box">
                        <div class="info-box-header">
                            <span class="info-box-icon"><span class="material-icons">lightbulb</span></span>
                            <span class="info-box-title">レイヤーキャッシュの活用</span>
                        </div>
                        <p><code>package*.json</code>を先にコピーしてから<code>npm ci</code>を実行し、その後にアプリケーションコードをコピーしています。これにより、コードのみ変更した場合は<code>npm ci</code>のレイヤーがキャッシュされ、ビルドが高速化されます。</p>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">2.3 .dockerignoreの設定</h3>
                <div class="content-block">
                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">backend/.dockerignore</span>
                            <span class="code-lang">Text</span>
                        </div>
                        <pre class="code-content"><code>node_modules
npm-debug.log
.git
.gitignore
.env
Dockerfile
docker-compose.yml
README.md</code></pre>
                    </div>
                    <p><code>.dockerignore</code>に<code>node_modules</code>を記載することで、ホスト側のnode_modulesがイメージにコピーされるのを防ぎ、コンテナ内で新たに<code>npm ci</code>でインストールされた正確な依存関係のみを使用します。</p>
                </div>
            </div>
        </section>

        <!-- セクション 7-3 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Section 7-3</span>
                <h2 class="section-title">Nginxリバースプロキシの構築</h2>
            </div>

            <div class="intro-text">
                <p>Nginxをリバースプロキシとして配置し、クライアントからのリクエストをNode.jsバックエンドに転送します。静的ファイルの配信やSSL終端も担当できる重要なコンポーネントです。</p>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">3.1 Nginx設定ファイル</h3>
                <div class="content-block">
                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">nginx/default.conf</span>
                            <span class="code-lang">Nginx</span>
                        </div>
                        <pre class="code-content"><code>upstream backend {
    server backend:3000;  # Docker Composeのサービス名で指定
}

server {
    listen 80;
    server_name localhost;

    # 静的ファイル
    location / {
        root /usr/share/nginx/html;
        try_files $uri $uri/ /index.html;
    }

    # APIリクエストをバックエンドに転送
    location /api/ {
        proxy_pass http://backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}</code></pre>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">3.2 Nginx用Dockerfile</h3>
                <div class="content-block">
                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">nginx/Dockerfile</span>
                            <span class="code-lang">Dockerfile</span>
                        </div>
                        <pre class="code-content"><code>FROM nginx:alpine

# デフォルトの設定を置き換え
COPY default.conf /etc/nginx/conf.d/default.conf

# 静的ファイルをコピー（必要に応じて）
# COPY ../frontend/dist /usr/share/nginx/html

EXPOSE 80</code></pre>
                    </div>

                    <div class="info-box">
                        <div class="info-box-header">
                            <span class="info-box-icon"><span class="material-icons">lightbulb</span></span>
                            <span class="info-box-title">リバースプロキシのメリット</span>
                        </div>
                        <p>Nginxをリバースプロキシとして使うことで、ロードバランシング、SSLの終端処理、静的ファイルの高速配信、セキュリティヘッダーの付与などが可能になります。Node.jsサーバーはAPIロジックに集中できます。</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- セクション 7-4 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Section 7-4</span>
                <h2 class="section-title">Docker Composeで統合管理</h2>
            </div>

            <div class="intro-text">
                <p>3つのコンテナ（Nginx, Node.js, MySQL）をDocker Composeで一括管理します。サービス間の依存関係やネットワーク設定をYAMLで宣言的に定義します。</p>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">4.1 docker-compose.ymlの作成</h3>
                <div class="content-block">
                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">docker-compose.yml（本番構成）</span>
                            <span class="code-lang">YAML</span>
                        </div>
                        <pre class="code-content"><code>services:
  # Nginx リバースプロキシ
  nginx:
    build: ./nginx
    ports:
      - "80:80"
    depends_on:
      - backend
    networks:
      - frontend

  # Node.js バックエンド
  backend:
    build: ./backend
    environment:
      DB_HOST: db
      DB_USER: root
      DB_PASSWORD: secret
      DB_NAME: myapp
      PORT: 3000
    depends_on:
      db:
        condition: service_healthy
    networks:
      - frontend
      - backend-db

  # MySQL データベース
  db:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: secret
      MYSQL_DATABASE: myapp
    volumes:
      - mysql-data:/var/lib/mysql
      - ./db/init.sql:/docker-entrypoint-initdb.d/init.sql
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - backend-db

networks:
  frontend:
  backend-db:

volumes:
  mysql-data:</code></pre>
                    </div>

                    <div class="info-box">
                        <div class="info-box-header">
                            <span class="info-box-icon"><span class="material-icons">lightbulb</span></span>
                            <span class="info-box-title">healthcheckとdepends_on</span>
                        </div>
                        <p><code>healthcheck</code>とdepends_onの<code>condition: service_healthy</code>を組み合わせることで、MySQLが完全に起動してからバックエンドを開始できます。これにより、DB接続エラーを防止できます。</p>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">4.2 起動と確認</h3>
                <div class="content-block">
                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">アプリケーションの起動と確認</span>
                            <span class="code-lang">Terminal</span>
                        </div>
                        <pre class="code-content"><code># 全サービスをビルド&起動
docker compose up -d --build

# 各サービスのステータスを確認
docker compose ps

# ログを確認
docker compose logs -f backend

# APIの動作確認
curl http://localhost/api/health

# 停止
docker compose down</code></pre>
                    </div>
                </div>
            </div>
        </section>

        <!-- セクション 7-5 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Section 7-5</span>
                <h2 class="section-title">本番向けイメージの最適化</h2>
            </div>

            <div class="intro-text">
                <p>本番環境に向けて、Dockerイメージのサイズを削減し、セキュリティを向上させるテクニックを学びます。マルチステージビルドを活用して、不要なファイルを含まない軽量なイメージを作成します。</p>
            </div>

            <!-- 図解: イメージサイズ最適化 -->
            <div class="visual-diagram">
                <div class="visual-diagram-title">イメージサイズの最適化比較</div>
                <div class="vd-bar">
                    <div class="vd-bar-seg" style="background:#e53935; flex:10;">
                        node:20<br>1.1GB
                    </div>
                    <div class="vd-bar-seg" style="background:#fb8c00; flex:4;">
                        node:20-slim<br>240MB
                    </div>
                    <div class="vd-bar-seg" style="background:#43a047; flex:2;">
                        node:20-alpine<br>130MB
                    </div>
                    <div class="vd-bar-seg" style="background:#1976D2; flex:1;">
                        マルチステージ<br>~50MB
                    </div>
                </div>
                <p style="text-align:center;font-size:0.7rem;color:#666;margin-top:8px;">ベースイメージの選択とマルチステージビルドで<strong>95%以上</strong>のサイズ削減が可能</p>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">5.1 マルチステージビルド</h3>
                <div class="content-block">
                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">最適化されたDockerfile（マルチステージビルド）</span>
                            <span class="code-lang">Dockerfile</span>
                        </div>
                        <pre class="code-content"><code># ===== ビルドステージ =====
FROM node:20-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
# TypeScriptのビルド等があればここで実行
# RUN npm run build

# ===== 本番ステージ =====
FROM node:20-alpine AS production

WORKDIR /app

# 本番の依存関係のみインストール
COPY package*.json ./
RUN npm ci --only=production &amp;&amp; npm cache clean --force

# ビルド成果物をコピー
COPY --from=builder /app/server.js ./
# COPY --from=builder /app/dist ./dist

# セキュリティ: 非rootユーザー
USER node

EXPOSE 3000
CMD ["node", "server.js"]</code></pre>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">5.2 最適化のチェックリスト</h3>
                <div class="content-block">
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>最適化項目</th>
                                <th>方法</th>
                                <th>効果</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>軽量ベースイメージ</strong></td>
                                <td>alpine版を使用</td>
                                <td>イメージサイズ大幅削減</td>
                            </tr>
                            <tr>
                                <td><strong>マルチステージビルド</strong></td>
                                <td>ビルドツールを本番から除外</td>
                                <td>不要なファイル削減</td>
                            </tr>
                            <tr>
                                <td><strong>.dockerignore</strong></td>
                                <td>不要ファイルを除外</td>
                                <td>ビルドコンテキスト軽量化</td>
                            </tr>
                            <tr>
                                <td><strong>レイヤー統合</strong></td>
                                <td>RUN命令を連結</td>
                                <td>レイヤー数削減</td>
                            </tr>
                            <tr>
                                <td><strong>非rootユーザー</strong></td>
                                <td>USER命令で指定</td>
                                <td>セキュリティ向上</td>
                            </tr>
                        </tbody>
                    </table>

                    <div class="warning-box">
                        <div class="warning-box-header">
                            <span class="warning-box-icon"><span class="material-icons">warning</span></span>
                            <span class="warning-box-title">Alpine版の注意点</span>
                        </div>
                        <p>Alpine Linuxはmusl libcを使用しているため、glibcに依存するネイティブモジュール（bcryptなど）が動作しない場合があります。その場合は<code>node:20-slim</code>（Debian slim版）を代替として検討してください。</p>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <h3 class="subsection-title">5.3 イメージサイズの確認</h3>
                <div class="content-block">
                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">イメージサイズの確認コマンド</span>
                            <span class="code-lang">Terminal</span>
                        </div>
                        <pre class="code-content"><code># イメージサイズの確認
docker images my-webapp

# イメージの各レイヤーのサイズを確認
docker history my-webapp:latest

# ビルド（キャッシュなし）
docker build --no-cache -t my-webapp:optimized ./backend</code></pre>
                    </div>
                </div>
            </div>
        </section>

        <!-- 練習問題 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Exercise</span>
                <h2 class="section-title">7章 練習問題</h2>
            </div>

            <div class="exercise-list">
                <div class="exercise-item">
                    <div class="exercise-number">Q1</div>
                    <div class="exercise-content">
                        <p>Dockerfileで<code>package*.json</code>を先にコピーしてから<code>npm ci</code>を実行し、その後にアプリケーションコードをコピーする理由はどれですか？</p>
                        <ol type="A">
                            <li>package.jsonが存在しないとCOPYコマンドがエラーになるため</li>
                            <li>依存関係のインストールレイヤーをキャッシュし、ビルドを高速化するため</li>
                            <li>Node.jsの仕様で先にpackage.jsonを読む必要があるため</li>
                            <li>セキュリティ上の理由で順序が決まっているため</li>
                        </ol>
                    </div>
                </div>

                <div class="exercise-item">
                    <div class="exercise-number">Q2</div>
                    <div class="exercise-content">
                        <p>マルチステージビルドの主な目的はどれですか？</p>
                        <ol type="A">
                            <li>ビルド時間を短縮する</li>
                            <li>複数のアプリケーションを1つのイメージにまとめる</li>
                            <li>ビルドに必要なツールを本番イメージから除外してサイズを削減する</li>
                            <li>複数のOSでビルドできるようにする</li>
                        </ol>
                    </div>
                </div>

                <div class="exercise-item">
                    <div class="exercise-number">Q3</div>
                    <div class="exercise-content">
                        <p>Docker Composeのdepends_onで<code>condition: service_healthy</code>を指定する目的はどれですか？</p>
                        <ol type="A">
                            <li>依存サービスのコンテナが作成されたら即座に起動する</li>
                            <li>依存サービスが正常に動作していることをhealthcheckで確認してから起動する</li>
                            <li>依存サービスのCPU使用率が低い時に起動する</li>
                            <li>依存サービスのログ出力を監視して起動する</li>
                        </ol>
                    </div>
                </div>
            </div>
        </section>

        <!-- 解答 -->
        <section class="section">
            <div class="section-header">
                <span class="section-number">Answer</span>
                <h2 class="section-title">7章 解説・解答</h2>
            </div>

            <div class="answer-list">
                <div class="answer-item">
                    <div class="answer-header">Q1の解答: B</div>
                    <div class="answer-content">
                        <p>Dockerはレイヤーキャッシュを利用してビルドを高速化します。<code>package*.json</code>が変更されない限り、<code>npm ci</code>のレイヤーはキャッシュされます。アプリケーションコードのみ変更した場合、依存関係のインストールをスキップでき、ビルド時間が大幅に短縮されます。</p>
                    </div>
                </div>

                <div class="answer-item">
                    <div class="answer-header">Q2の解答: C</div>
                    <div class="answer-content">
                        <p>マルチステージビルドでは、ビルドステージで使用したコンパイラやビルドツールを本番ステージに含めずに済みます。最終的なイメージにはアプリケーションの実行に必要なファイルのみが含まれるため、イメージサイズの大幅な削減とセキュリティの向上が実現できます。</p>
                    </div>
                </div>

                <div class="answer-item">
                    <div class="answer-header">Q3の解答: B</div>
                    <div class="answer-content">
                        <p><code>condition: service_healthy</code>は、依存サービスのhealthcheckが成功（healthy状態）になるまで待機してから起動します。これにより、例えばMySQLが完全に初期化されてからバックエンドが起動するため、「接続拒否」エラーを回避できます。</p>
                    </div>
                </div>
            </div>
        </section>
    </div>

    <div class="page-nav">
        <a href="6docker-volume-network.html" class="page-nav-btn prev">
            <span>&#8592;</span>
            <div>
                <div class="page-nav-label">前の章</div>
                <div class="page-nav-title">第6章 ボリュームとネットワーク</div>
            </div>
        </a>
        <a href="8docker-hub.html" class="page-nav-btn next">
            <div>
                <div class="page-nav-label">次の章</div>
                <div class="page-nav-title">第8章 Docker Hubとイメージ管理</div>
            </div>
            <span>&#8594;</span>
        </a>
    </div>

    <footer class="global-footer"></footer>
    <script src="../shared/footer.js"></script>
    <script>
        document.addEventListener('click', function(e) {
            const header = document.querySelector('.global-header');
            const nav = document.querySelector('.tutorial-nav');
            const toggle = document.querySelector('.header-nav-toggle');
            if (header && nav && toggle && !header.contains(e.target) && !nav.contains(e.target) && nav.classList.contains('active')) {
                toggle.classList.remove('active');
                nav.classList.remove('active');
            }
        });
    </script>
</body>
</html>